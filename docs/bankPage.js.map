{"version":3,"sources":["webpack://bank-puzzle/./app/bank.ts","webpack://bank-puzzle/./node_modules/grainjs/index.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/PriorityQueue.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/_computed_queue.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/binding.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/browserGlobals.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/computed.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/dispose.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/dom.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/domComponent.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/domComputed.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/domDispose.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/domForEach.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/domImpl.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/domMethods.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/domevent.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/emit.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/kowrap.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/obsArray.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/observable.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/pureComputed.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/styled.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/subscribe.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/util.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/widgets/input.ts","webpack://bank-puzzle/./node_modules/grainjs/lib/widgets/select.ts","webpack://bank-puzzle/webpack/bootstrap","webpack://bank-puzzle/webpack/runtime/define property getters","webpack://bank-puzzle/webpack/runtime/hasOwnProperty shorthand","webpack://bank-puzzle/webpack/runtime/make namespace object","webpack://bank-puzzle/./app/bankPage.ts"],"names":[],"mappings":"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","file":"bankPage.js","sourcesContent":["export type AccountId = string;\n\n// This simple bank maintains account balances in this map.\nconst bankBalances: Map<AccountId, number> = new Map();\n\n// Initialize the bankBalances to 3 accounts, each starting out\n// with an initial balankce of $1000.\nexport async function initialize() {\n  bankBalances.clear();\n  bankBalances.set(\"A\", 1000);\n  bankBalances.set(\"B\", 1000);\n  bankBalances.set(\"C\", 1000);\n}\n\n// Method to retrieve the balance for an account.\nexport async function getBalance(accountId: AccountId) {\n  const balance = bankBalances.get(accountId);\n  if (typeof balance !== 'number') {\n    throw new Error(`Invalid accountID ${accountId}`);\n  }\n  return balance;\n}\n\n// Transfer a given amount from one account to another. The amount\n// must be positive, and must not exceed the balance in accFrom.\nexport async function transfer(\n  accFrom: AccountId, accTo: AccountId, amount: number\n) {\n  if (accFrom === accTo) {\n    throw new Error(`Transfer accounts must be different`);\n  }\n  const balanceFrom = await getBalance(accFrom);\n  const balanceTo = await getBalance(accTo);\n\n  if (typeof amount !== 'number' || !(amount > 0)) {\n    throw new Error(`Invalid amount ${amount}`);\n  }\n  if (amount > balanceFrom) {\n    throw new Error(`Insufficient balance`);\n  }\n\n  await moneyLaunderingCheck(amount);\n\n  bankBalances.set(accFrom, balanceFrom - amount);\n  bankBalances.set(accTo, balanceTo + amount);\n}\n\n// Pretend to run some extra checks. These are quite fast, taking\n// around 100ms, and happen to always pass.\nexport async function moneyLaunderingCheck(amount: number) {\n  return new Promise(resolve => setTimeout(resolve, 100));\n}\n","export * from './lib/binding';\nexport * from './lib/computed';\nexport * from './lib/dispose';\nexport * from './lib/dom';\nexport * from './lib/emit';\nexport * from './lib/kowrap';\nexport * from './lib/obsArray';\nexport * from './lib/observable';\nexport * from './lib/pureComputed';\nexport * from './lib/styled';\nexport * from './lib/subscribe';\nexport * from './lib/util';\nexport * from './lib/widgets/input';\nexport * from './lib/widgets/select';\n","/**\n * A simple and fast priority queue with a limited interface to push, pop, peek, and get size. It\n * is essentially equivalent to both npm modules 'fastpriorityqueue' and 'qheap', but is in\n * TypeScript and is a bit cleaner and simpler.\n *\n * It is constructed with a function that returns which of two items is \"prior\"; the pop() method\n * returns the most-prior element.\n */\n\nexport type IsPriorFunc<T> = (a: T, b: T) => boolean;\n\nexport class PriorityQueue<T> {\n  // Items form a binary tree packed into an array. Root is items[0]; children of items[i] are\n  // items[2*i+1] and items[2*i+2]; parent of items[i] is items[(i - 1) >> 1]. For all children,\n  // the invariant isPrior(parent, child) holds.\n  private _items: T[] = [];\n\n  constructor(private _isPrior: IsPriorFunc<T>) {}\n\n  public get size(): number { return this._items.length; }\n\n  public push(item: T): void {\n    const items = this._items;\n    const isPrior = this._isPrior;\n\n    let curIdx = this._items.length;\n    while (curIdx > 0) {\n      // While we have a parent that is not prior to us, bubble up the \"hole\" at items.length.\n      const parIdx = (curIdx - 1) >> 1;   // tslint:disable-line:no-bitwise\n      const parItem = items[parIdx];\n      if (isPrior(parItem, item)) {\n        break;\n      }\n      items[curIdx] = parItem;\n      curIdx = parIdx;\n    }\n    items[curIdx] = item;\n  }\n\n  public peek(): T|undefined {\n    return this._items[0];\n  }\n\n  public pop(): T|undefined {\n    if (this._items.length <= 1) { return this._items.pop(); }\n    const items = this._items;\n    const isPrior = this._isPrior;\n    const result = items[0];\n\n    // Bubble the last item downwards from the root.\n    const item = items.pop()!;\n    const size = this._items.length;\n    let curIdx = 0;\n    let leftIdx = 1;\n    while (leftIdx < size) {\n      const rightIdx = leftIdx + 1;\n      const bestIdx = (rightIdx < size && isPrior(items[rightIdx], items[leftIdx])) ?\n        rightIdx : leftIdx;\n      if (isPrior(item, items[bestIdx])) {\n        break;\n      }\n      items[curIdx] = items[bestIdx];\n      curIdx = bestIdx;\n      leftIdx = curIdx + curIdx + 1;\n    }\n    items[curIdx] = item;\n    return result;\n  }\n}\n","/**\n * This module supports computed observables, organizing them into a priority queue, so that\n * computeds can be updated just once after multiple bundled changes.\n *\n * This module is for internal use only (hence the leading underscore in the name). The only\n * function useful outside is exposed via the `observable` module as `observable.bundleChanges()`.\n *\n * Changes may come together because multiple observables are changed synchronously, or because\n * multiple computeds depend on a single changed observable. In either case, if a computed depends\n * on multiple observables that are being changed, we want it to just get updated once when the\n * changes are complete.\n *\n * This is done by maintaining a _priority in each computed, where greater values get evaluated\n * later (computed with greater values depend on those with smaller values). When a computed needs\n * updating, it adds itself to the queue using enqueue() method. At the end of an observable.set()\n * call, or of bundleChanges() call, the queue gets processed in order of _priority.\n */\n\nimport {PriorityQueue} from './PriorityQueue';\n\n/**\n * DepItem is an item in a dependency relationship. It may depend on other DepItems. It is used\n * for subscriptions and computed observables.\n */\nexport class DepItem {\n  public static isPrioritySmaller(a: DepItem, b: DepItem): boolean {\n    return a._priority < b._priority || (a._priority === b._priority && a._creation < b._creation);\n  }\n\n  private _priority: number = 0;\n  private _enqueued: boolean = false;\n  private _callback: () => void;\n  private _context?: object;\n\n  // Order of creation, used for ordering items at same priority.\n  private _creation: number = ++_nextCreationNum;\n\n  /**\n   * Callback should call depItem.useDep(dep) for each DepInput it depends on.\n   */\n  constructor(callback: () => void, optContext?: object) {\n    this._callback = callback;\n    this._context = optContext;\n  }\n\n  /**\n   * Mark depItem as a dependency of this DepItem. The argument may be null to indicate a leaf (an\n   * item such as a plain observable, which does not itself depend on anything else).\n   */\n  public useDep(depItem: DepItem|null): void {\n    const p = depItem ? depItem._priority : 0;\n    if (p >= this._priority) {\n      this._priority = p + 1;\n    }\n  }\n\n  /**\n   * Recompute this DepItem, calling the callback given in the constructor.\n   */\n  public recompute(): void {\n    this._priority = 0;\n    this._callback.call(this._context);\n  }\n\n  /**\n   * Add this DepItem to the queue, to be recomputed when the time is right.\n   */\n  public enqueue(): void {\n    if (!this._enqueued) {\n      this._enqueued = true;\n      queue.push(this);\n    }\n  }\n}\n\n// The main compute queue.\nconst queue = new PriorityQueue<DepItem>(DepItem.isPrioritySmaller);\n\n// Counter for creation order, used to create a stable ordering of DepItems at same priority.\nlet _nextCreationNum = 0;\n\n// Array to keep track of items recomputed during this call to compute(). It could be a local\n// variable in compute(), but is made global to minimize allocations.\nconst _seen: any[] = [];\n\n// Counter used for bundling multiple calls to compute() into one.\nlet bundleDepth = 0;\n\n/**\n * Exposed for unittests. Returns the internal priority value of an observable.\n */\nexport function _getPriority(obs: any): number {\n  const depItem = obs._getDepItem();\n  return depItem ? depItem._priority : 0;\n}\n\n/**\n * Update any computed observables that need updating. The update is deferred if we are currently\n * in the middle of a bundle. This is called automatically whenever you set an observable, and\n * there should be no need to ever call this by users of the library.\n */\nexport function compute(): void {\n  if (bundleDepth === 0 && queue.size > 0) {\n    // Prevent nested compute() calls, which are unnecessary and can cause deep recursion stack.\n    bundleDepth++;\n    try {\n      // We reuse _seen array to minimize allocations, but always leave it empty.\n      do {\n        const item = queue.pop()!;\n        _seen.push(item);\n        item.recompute();\n      } while (queue.size > 0);\n    } finally {\n      // We delay the unsetting of _enqueued flag to here, to protect against infinite loops when\n      // a change to a computed causes it to get enqueued again.\n      for (const item of _seen) {\n        item._enqueued = false;\n      }\n      _seen.length = 0;\n      bundleDepth--;\n    }\n  }\n}\n\n/**\n * Defer recomputations of all computed observables and subscriptions until func() returns. This\n * is useful to avoid unnecessary recomputation if you are making several changes to observables\n * together. This function is exposed as `observable.bundleChanges()`.\n *\n * Note that this intentionally does not wait for promises to be resolved, since that would block\n * all updates to all computeds while waiting.\n */\nexport function bundleChanges<T>(func: () => T): T {\n  try {\n    bundleDepth++;\n    return func();\n  } finally {\n    bundleDepth--;\n    compute();\n  }\n}\n","/**\n * binding.ts offers a convenient subscribe() function that creates a binding to an observable, a\n * a plain value, or a function from which it builds a computed.\n */\n\nimport {computed} from './computed';\nimport {IDisposable} from './dispose';\nimport {autoDisposeElem} from './domDispose';\nimport {IKnockoutReadObservable, InferKoType} from './kowrap';\nimport {BaseObservable} from './observable';\nimport {subscribe, UseCBOwner} from './subscribe';\n\nexport type BindableValue<T> = BaseObservable<T> | ComputedCallback<T> | T | IKnockoutReadObservable<T>;\n\nexport type ComputedCallback<T> = (use: UseCBOwner, ...args: any[]) => T;\n\n/**\n * Subscribes a callback to valueObs, which may be one a plain value, an observable, a knockout\n * observable, or a function. If a function, it's used to create a computed() and will be called\n * with a context function `use`, allowing it to depend on other observable values (see\n * documentation for `computed`).\n *\n * In all cases, `callback(newValue, oldValue)` is called immediately and whenever the value\n * changes. On the initial call, oldValue is undefined.\n *\n * Returns an object which should be disposed to remove the created subscriptions, or null.\n */\n// The overload below is annoying, but needed for correct type inference; see test/types/kowrap.ts.\nexport function subscribeBindable<KObs extends IKnockoutReadObservable<any>>(\n    valueObs: KObs, callback: (val: InferKoType<KObs>) => void): IDisposable|null;\nexport function subscribeBindable<T>(\n    valueObs: BindableValue<T>, callback: (val: T) => void): IDisposable|null;\nexport function subscribeBindable<T>(\n    valueObs: BindableValue<T>, callback: (val: T) => void): IDisposable|null {\n  // A plain function (to make a computed from), or a knockout observable.\n  if (typeof valueObs === 'function') {\n    // Knockout observable.\n    const koValue = valueObs as IKnockoutReadObservable<T>;\n    if (typeof koValue.peek === 'function') {\n      const sub = koValue.subscribe((val) => callback(val));\n      callback(koValue.peek());\n      return sub;\n    }\n\n    // Function from which to make a computed. Note that this is also reasonable:\n    //    let sub = subscribe(use => callback(valueObs(use)));\n    // The difference is that when valueObs() evaluates to unchanged value, callback would be\n    // called in the version above, but not in the version below.\n    const comp = computed(valueObs as ComputedCallback<T>);\n    comp.addListener((val) => callback(val));\n    callback(comp.get());\n    return comp;      // Disposing this will dispose its one listener.\n  }\n\n  // An observable.\n  if (valueObs instanceof BaseObservable) {\n    // Use subscribe() rather than addListener(), so that bundling of changes (implicit and with\n    // bundleChanges()) is respected. This matters when callback also uses observables.\n    return subscribe(valueObs, (use, val) => callback(val));\n  }\n\n  callback(valueObs);\n  return null;\n}\n\n/**\n * Subscribes a callback to valueObs (which may be a value, observable, or function) using\n * subscribe(), and disposes the subscription with the passed-in element.\n */\nexport function subscribeElem<T>(elem: Node, valueObs: BindableValue<T>,\n                                 callback: (newVal: T, oldVal?: T) => void): void {\n  autoDisposeElem(elem, subscribeBindable(valueObs, callback));\n}\n","/**\n * Module that allows client-side code to use browser globals (such as `document` or `Node`) in a\n * way that allows those globals to be replaced by mocks in browser-less tests.\n *\n *    import {G} from 'browserGlobals';\n *    ... use G.document\n *    ... use G.Node\n *\n * Initially, the global `window` object, is the source of the global values.\n *\n * To use a mock of globals in a test, use:\n *\n *    import {pushGlobals, popGlobals} as G from 'browserGlobals';\n *    before(function() {\n *      pushGlobals(mockWindow);    // e.g. jsdom.jsdom(...).defaultView\n *    });\n *    after(function() {\n *      popGlobals();\n *    });\n */\n\nexport interface IBrowserGlobals {\n  DocumentFragment: typeof DocumentFragment;\n  Element: typeof Element;\n  Node: typeof Node;\n  document: typeof document;\n  window: typeof window;\n}\n\nfunction _updateGlobals(dest: IBrowserGlobals, source: IBrowserGlobals): void {\n  dest.DocumentFragment  = source.DocumentFragment;\n  dest.Element           = source.Element;\n  dest.Node              = source.Node;\n  dest.document          = source.document;\n  dest.window            = source.window;\n}\n\n// The initial IBrowserGlobals object.\nconst initial: IBrowserGlobals = {} as IBrowserGlobals;\n_updateGlobals(initial, (typeof window !== 'undefined' ? window as any : {}));\n\n// The globals G object strats out with a copy of `initial`.\nexport const G: IBrowserGlobals = { ...initial };\n\n// The stack of globals that always has the intial object, but which may be overridden.\nconst _globalsStack: IBrowserGlobals[] = [initial];\n\n/**\n * Replace globals with those from the given object. Use popGlobals() to restore previous values.\n */\nexport function pushGlobals(globals: IBrowserGlobals): void {\n  _globalsStack.push(globals);\n  _updateGlobals(G, globals);\n}\n\n/**\n * Restore the values of globals to undo the preceding pushGlobals() call.\n */\nexport function popGlobals(): void {\n  if (_globalsStack.length > 1) {\n    _globalsStack.pop();\n  }\n  _updateGlobals(G, _globalsStack[_globalsStack.length - 1]);\n}\n","/**\n * computed.js implements a computed observable, whose value depends on other observables and gets\n * recalculated automatically when they change.\n *\n * E.g. if we have some existing observables (which may themselves be instances of `computed`),\n * we can create a computed that subscribes to them explicitly:\n *  let obs1 = observable(5), obs2 = observable(12);\n *  let computed1 = computed(obs1, obs2, (use, v1, v2) => v1 + v2);\n *\n * or implicitly by using `use(obs)` function:\n *  let computed2 = computed(use => use(obs1) + use(obs2));\n *\n * In either case, computed1.get() and computed2.get() will have the value 17. If obs1 or obs2 is\n * changed, computed1 and computed2 will get recomputed automatically.\n *\n * Creating a computed allows any number of dependencies to be specified explicitly, and their\n * values will be passed to the read() callback. These may be combined with automatic dependencies\n * detected using use(). Note that constructor dependencies have less overhead.\n *\n *  let val = computed(...deps, ((use, ...depValues) => READ_CALLBACK));\n *\n * You may specify a `write` callback by calling `onWrite(WRITE_CALLBACK)`, which will be called\n * whenever set() is called on the computed by its user. If a `write` bacllback is not specified,\n * calling `set` on a computed observable will throw an exception.\n *\n * Note that pureComputed.js offers a variation of computed() with the same interface, but which\n * stays unsubscribed from dependencies while it itself has no subscribers.\n *\n * A computed may be used with a disposable value using `use.owner` as the value's owner. E.g.\n *    let val = computed((use) => Foo.create(use.owner, use(a), use(b)));\n *\n * When the computed() is re-evaluated, and when it itself is disposed, it disposes the previously\n * owned value. Note that only the pattern above works, i.e. use.owner may only be used to take\n * ownership of the same disposable that the callback returns.\n */\n\nimport {DepItem} from './_computed_queue';\nimport {IDisposableOwnerT, setDisposeOwner} from './dispose';\nimport {BaseObservable as Obs, Observable} from './observable';\nimport {ISubscribable, Subscription, UseCBOwner as UseCB} from './subscribe';\n\nfunction _noWrite(): never {\n  throw new Error(\"Can't write to non-writable computed\");\n}\n\ntype Owner<T> = IDisposableOwnerT<Computed<T>>|null;\n\nexport class Computed<T> extends Observable<T> {\n  // Still need repetitive declarations to support varargs that are not the final argument.\n  public static create<T>(\n    owner: Owner<T>, cb: (use: UseCB) => T): Computed<T>;\n  public static create<T, A>(\n    owner: Owner<T>, a: Obs<A>,\n    cb: (use: UseCB, a: A) => T): Computed<T>;\n  public static create<T, A, B>(\n    owner: Owner<T>, a: Obs<A>, b: Obs<B>,\n    cb: (use: UseCB, a: A, b: B) => T): Computed<T>;\n  public static create<T, A, B, C>(\n    owner: Owner<T>, a: Obs<A>, b: Obs<B>, c: Obs<C>,\n    cb: (use: UseCB, a: A, b: B, c: C) => T): Computed<T>;\n  public static create<T, A, B, C, D>(\n    owner: Owner<T>, a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>,\n    cb: (use: UseCB, a: A, b: B, c: C, d: D) => T): Computed<T>;\n  public static create<T, A, B, C, D, E>(\n    owner: Owner<T>, a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>, e: Obs<E>,\n    cb: (use: UseCB, a: A, b: B, c: C, d: D, e: E) => T): Computed<T>;\n\n  /**\n   * Creates a new Computed, owned by the given owner.\n   * @param owner: Object to own this Computed, or null to handle disposal manually.\n   * @param ...observables: Zero or more observables on which this computes depends. The callback\n   *        will get called when any of these changes.\n   * @param callback: Read callback that will be called with (use, ...values),\n   *    i.e. the `use` function and values for all of the ...observables. The callback is called\n   *    immediately and whenever any dependency changes.\n   * @returns {Computed} The newly created computed observable.\n   */\n  public static create<T>(owner: IDisposableOwnerT<Computed<T>>|null, ...args: any[]): Computed<T> {\n    const readCb = args.pop();\n    return setDisposeOwner(owner, new Computed<T>(readCb, args));\n  }\n\n  private _callback: (use: UseCB, ...args: any[]) => T;\n  private _write: (value: T) => void;\n  private _sub: Subscription;\n\n  /**\n   * Internal constructor for a Computed observable. You should use computed() function instead.\n   */\n  constructor(callback: (use: UseCB, ...args: any[]) => T, dependencies: ISubscribable[]) {\n    // At initialization we force an undefined value even though it's not of type T: it gets set\n    // to a proper value during the creation of new Subscription, which calls this._read.\n    super(undefined as any);\n    this._callback = callback;\n    this._write = _noWrite;\n    this._sub = new Subscription(this._read.bind(this), dependencies, this);\n  }\n\n  /**\n   * Used by subscriptions to keep track of dependencies.\n   */\n  public _getDepItem(): DepItem {\n    return this._sub._getDepItem();\n  }\n\n  /**\n   * \"Sets\" the value of the computed by calling the write() callback if one was provided in the\n   * constructor. Throws an error if there was no such callback (not a \"writable\" computed).\n   * @param {Object} value: The value to pass to the write() callback.\n   */\n  public set(value: T): void { this._write(value); }\n\n  /**\n   * Set callback to call when this.set(value) is called, to make it a writable computed. If not\n   * set, attempting to write to this computed will throw an exception.\n   */\n  public onWrite(writeFunc: (value: T) => void): Computed<T> {\n    this._write = writeFunc;\n    return this;\n  }\n\n  /**\n   * Disposes the computed, unsubscribing it from all observables it depends on.\n   */\n  public dispose() {\n    this._sub.dispose();\n    super.dispose();\n  }\n\n  private _read(use: any, ...args: any[]): void {\n    super.set(this._callback(use as UseCB, ...args));\n  }\n}\n\n/**\n * This is the type-checking interface for computed(), which allows TypeScript to do helpful\n * type-checking when using it. We can only support a fixed number of argumnets (explicit\n * dependencies), but 5 should almost always be enough.\n */\nexport function computed<T>(cb: (use: UseCB) => T): Computed<T>;\n\nexport function computed<T, A>(\n  a: Obs<A>,\n  cb: (use: UseCB, a: A) => T): Computed<T>;\n\nexport function computed<T, A, B>(\n  a: Obs<A>, b: Obs<B>,\n  cb: (use: UseCB, a: A, b: B) => T): Computed<T>;\n\nexport function computed<T, A, B, C>(\n  a: Obs<A>, b: Obs<B>, c: Obs<C>,\n  cb: (use: UseCB, a: A, b: B, c: C) => T): Computed<T>;\n\nexport function computed<T, A, B, C, D>(\n  a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>,\n  cb: (use: UseCB, a: A, b: B, c: C, d: D) => T): Computed<T>;\n\nexport function computed<T, A, B, C, D, E>(\n  a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>, e: Obs<E>,\n  cb: (use: UseCB, a: A, b: B, c: C, d: D, e: E) => T): Computed<T>;\n\n/**\n * Creates a new Computed.\n * @param {Observable} ...observables: The initial params, of which there may be zero or more, are\n *    observables on which this computed depends. When any of them change, the read() callback\n *    will be called with the values of these observables as arguments.\n * @param {Function} readCallback: Read callback that will be called with (use, ...values),\n *    i.e. the `use` function and values for all of the ...observables. The callback is called\n *    immediately and whenever any dependency changes.\n * @returns {Computed} The newly created computed observable.\n */\nexport function computed(...args: any[]): Computed<any> {\n  const readCb = args.pop();\n  return new Computed<any>(readCb, args);\n}\n\n// TODO Consider implementing .singleUse() method.\n// An open question is in how to pass e.g. kd.hide(computed(x, x => !x)) in such a way that\n// the temporary computed can be disposed when temporary, but not otherwise. A function-only\n// syntax is kd.hide(use => !use(x)), but prevents use of static subscriptions.\n//\n// (a) function-only use of computeds is fine and useful.\n// (b) pureComputed is another option, and doesn't technically require getting disposed.\n// (c) kd.hide(compObs), kd.autoDispose(compObs) is more general and\n//     can be replaced more concisely by kd.hide(compObs.singleUse())\n// .singleUse() automatically disposes a computed (or an observable?) once there are no\n// subscriptions to it. If there are no subscriptions at the time of this call, waits for the next\n// tick, and possibly disposes then.\n","/**\n * dispose.js provides tools to objects that needs to dispose resources, such as destroy DOM, and\n * unsubscribe from events. The motivation with examples is presented here:\n *\n *    https://phab.getgrist.com/w/disposal/\n *\n * Disposable is a class for components that need cleanup (e.g. maintain DOM, listen to events,\n * subscribe to anything). It provides a .dispose() method that should be called to destroy the\n * component, and .onDispose()/.autoDispose() methods that the component should use to take\n * responsibility for other pieces that require cleanup.\n *\n * To define a disposable class:\n *    class Foo extends Disposable { ... }\n *\n * To create Foo:\n *    const foo = Foo.create(owner, ...args);\n * This is better than `new Foo` for two reasons:\n *    1. If Foo's constructor throws an exception, any disposals registered in that constructor\n *       before the exception are honored.\n *    2. It ensures you specify the owner of the new instance (but you can use null to skip it).\n *\n * In Foo's constructor (or rarely methods), take ownership of other Disposable objects:\n *    this.bar = Bar.create(this, ...);\n *\n * For objects that are not instances of Disposable but have a .dispose() methods, use:\n *    this.bar = this.autoDispose(createSomethingDisposable());\n *\n * To call a function on disposal (e.g. to add custom disposal logic):\n *    this.onDispose(() => this.myUnsubscribeAllMethod());\n *    this.onDispose(this.myUnsubscribeAllMethod, this);    // slightly more efficient\n *\n * To mark this object to be wiped out on disposal (i.e. set all properties to null):\n *    this.wipeOnDispose();\n * See the documentation of that method for more info.\n *\n * To dispose Foo directly:\n *    foo.dispose();\n * To determine if an object has already been disposed:\n *    foo.isDisposed()\n *\n * If you need to replace an owned object, or release, or dispose it early, use a Holder:\n *    this._holder = Holder.create(this);\n *    Bar.create(this._holder, 1);      // creates new Bar(1)\n *    Bar.create(this._holder, 2);      // creates new Bar(2) and disposes previous object\n *    this._holder.clear();             // disposes contained object\n *    this._holder.release();           // releases contained object\n *\n * If you need a container for multiple objects and dispose them all together, use a MultiHolder:\n *    this._mholder = MultiHolder.create(null);\n *    Bar.create(this._mholder, 1);     // create new Bar(1)\n *    Bar.create(this._mholder, 2);     // create new Bar(2)\n *    this._mholder.dispose();          // disposes both objects\n *\n * If creating your own class with a dispose() method, do NOT throw exceptions from dispose().\n * These cannot be handled properly in all cases. Read here about the same issue in C++:\n *    http://bin-login.name/ftp/pub/docs/programming_languages/cpp/cffective_cpp/MAGAZINE/SU_FRAME.HTM#destruct\n *\n * Using a parametrized (generic) class as a Disposable is tricky. E.g.\n *    class Bar<T> extends Disposable { ... }\n *    // Bar<T>.create(...)   <-- doesn't work\n *    // Bar.create<T>(...)   <-- doesn't work\n *    // Bar.create(...)      <-- works, but with {} for Bar's type parameters\n *\n * The solution is to expose the constructor type using a helper method:\n *    class Bar<T> extends Disposable {\n *      // Note the tuple below which must match the constructor parameters of Bar<U>.\n *      public static ctor<U>(): IDisposableCtor<Bar<U>, [U, boolean]> { return this; }\n *      constructor(a: T, b: boolean) { ... }\n *    }\n *    Bar.ctor<T>().create(...)   // <-- works, creates Bar<T>, and does type-checking!\n */\n\nimport {LLink} from './emit';\n\n/**\n * Anything with a .dispose() method is a disposable object, and implements the IDisposable interface.\n */\nexport interface IDisposable {\n  dispose(): void;\n}\n\n/**\n * Anything with .autoDispose() can be the owner of a disposable object. This is a type-specific\n * class that can only own a disposable object of type T.\n */\nexport interface IDisposableOwnerT<T extends IDisposable> {\n  autoDispose(obj: T): void;\n}\n\n/**\n * Type that can own an object of any disposable type.\n */\nexport interface IDisposableOwner {\n  autoDispose(obj: IDisposable): void;\n}\n\n// Internal \"owner\" of disposable objects which doesn't actually dispose or keep track of them. It\n// is the effective owner when creating a Disposable with `new Foo()` rather than `Foo.create()`.\nconst _noopOwner: IDisposableOwner = {\n  autoDispose(obj: IDisposable): void { /* noop */ },\n};\n\n// Newly-created Disposable instances will have this as their owner. This is not a constant, it\n// is used by create() for the safe creation of Disposables.\nlet _defaultDisposableOwner = _noopOwner;\n\n/**\n * The static portion of class Disposable.\n */\nexport interface IDisposableCtor<Derived, CtorArgs extends any[]> {\n  new(...args: CtorArgs): Derived;\n  create<T extends new(...args: any[]) => any>(\n    this: T, owner: IDisposableOwnerT<InstanceType<T>>|null, ...args: ConstructorParameters<T>): InstanceType<T>;\n}\n\n/**\n * Base class for disposable objects that can own other objects. See the module documentation.\n */\nexport abstract class Disposable implements IDisposable, IDisposableOwner {\n  /**\n   * Create Disposable instances using `Class.create(owner, ...)` rather than `new Class(...)`.\n   *\n   * This reminds you to provide an owner, and ensures that if the constructor throws an\n   * exception, dispose() gets called to clean up the partially-constructed object.\n   *\n   * Owner may be null if intend to ensure disposal some other way.\n   */\n  public static create<T extends new (...args: any[]) => any>(\n    this: T, owner: IDisposableOwnerT<InstanceType<T>>|null, ...args: ConstructorParameters<T>): InstanceType<T> {\n\n    const origDefaultOwner = _defaultDisposableOwner;\n    const holder = new Holder();\n    try {\n      // The newly-created object will have holder as its owner.\n      _defaultDisposableOwner = holder;\n      return setDisposeOwner(owner, new this(...args));\n    } catch (e) {\n      try {\n        // This calls dispose on the partially-constructed object\n        holder.clear();\n      } catch (e2) {\n        // tslint:disable-next-line:no-console\n        console.error(\"Error disposing partially constructed %s:\", this.name, e2);\n      }\n      throw e;\n    } finally {\n      // On success, the new object has a new owner, and we release it from holder.\n      // On error, the holder has been cleared, and the release() is a no-op.\n      holder.release();\n      _defaultDisposableOwner = origDefaultOwner;\n    }\n  }\n\n  private _disposalList: DisposalList = new DisposalList();\n\n  constructor() {\n    // This registers with a temp Holder when using create(), and is a no-op when using `new Foo`.\n    _defaultDisposableOwner.autoDispose(this);\n    // Be sure to reset to no-op, so that a (non-recommended) direct call like 'new Bar()', from\n    // inside Foo's constructor doesn't use the same Holder that's temporarily holding Foo.\n    _defaultDisposableOwner = _noopOwner;\n  }\n\n  /** Take ownership of obj, and dispose it when this.dispose() is called. */\n  public autoDispose<T extends IDisposable>(obj: T): T {\n    this.onDispose(obj.dispose, obj);\n    return obj;\n  }\n\n  /** Call the given callback when this.dispose() is called. */\n  public onDispose<T>(callback: (this: T) => void, context?: T): DisposeListener {\n    return this._disposalList.addListener(callback, context);\n  }\n\n  /**\n   * Wipe out this object when it is disposed, i.e. set all its properties to null. It is\n   * recommended to call this early in the constructor.\n   *\n   * This makes disposal more costly, but has certain benefits:\n   * - If anything still refers to the object and uses it, we'll get an early error, rather than\n   *   silently keep going, potentially doing useless work (or worse) and wasting resources.\n   * - If anything still refers to the object (even without using it), the fields of the object\n   *   can still be garbage-collected.\n   * - If there are circular references involving this object, they get broken, making the job\n   *   easier for the garbage collector.\n   *\n   * The recommendation is to use it for complex, longer-lived objects, but to skip for objects\n   * which are numerous and short-lived (and less likely to be referenced from unexpected places).\n   */\n  public wipeOnDispose(): void {\n    this.onDispose(this._wipeOutObject, this);\n  }\n\n  /**\n   * Returns whether this object has already been disposed.\n   */\n  public isDisposed(): boolean {\n    return this._disposalList === null;\n  }\n\n  /**\n   * Clean up `this` by disposing all owned objects, and calling onDispose() callbacks, in reverse\n   * order to that in which they were added.\n   */\n  public dispose(): void {\n    const disposalList = this._disposalList;\n    if (!disposalList) {\n        // tslint:disable-next-line:no-console\n      console.error(\"Error disposing %s which is already disposed\", _describe(this));\n    } else {\n      this._disposalList = null!;\n      disposalList.callAndDispose(this);\n    }\n  }\n\n  /**\n   * Wipe out this object by setting each property to null. This is helpful for objects that are\n   * disposed and should be ready to be garbage-collected.\n   */\n  private _wipeOutObject(): void {\n    // The sentinel value doesn't have to be null, but some values cause more helpful errors than\n    // others. E.g. if a.x = \"disposed\", then a.x.foo() throws \"undefined is not a function\", but\n    // when a.x = null, a.x.foo() throws a more helpful \"Cannot read property 'foo' of null\".\n    for (const k of Object.keys(this)) {\n      (this as any)[k] = null;\n    }\n  }\n}\n\n/**\n * Holder keeps a single disposable object. If given responsibility for another object using\n * holder.autoDispose() or Foo.create(holder, ...), it automatically disposes the currently held\n * object. It also disposes it when the holder itself is disposed.\n *\n * If the object is an instance of Disposable, the holder will also notice when the object gets\n * disposed from outside of it, in which case the holder will become empty again.\n */\nexport class Holder<T extends IDisposable> implements IDisposable, IDisposableOwner {\n  public static create<T extends IDisposable>(owner: IDisposableOwnerT<Holder<T>>|null): Holder<T> {\n    return setDisposeOwner(owner, new Holder<T>());\n  }\n\n  protected _owned: T|null = null;\n  private _disposalListener: DisposeListener|undefined = undefined;\n\n  /** Take ownership of a new object, disposing the previously held one. */\n  public autoDispose(obj: T): T {\n    this.clear();\n    this._owned = obj;\n    if (obj instanceof Disposable) {\n      this._disposalListener = obj.onDispose(this._onOutsideDispose, this);\n    }\n    return obj;\n  }\n\n  /** Releases the held object without disposing it, emptying the holder. */\n  public release(): IDisposable|null {\n    this._unlisten();\n    const ret = this._owned;\n    this._owned = null;\n    return ret;\n  }\n\n  /** Disposes the held object and empties the holder. */\n  public clear(): void {\n    this._unlisten();\n    const owned = this._owned;\n    if (owned) {\n      this._owned = null;\n      owned.dispose();\n    }\n  }\n\n  /** Returns the held object, or null if the Holder is empty. */\n  public get(): T|null { return this._owned; }\n\n  /** Returns whether the Holder is empty. */\n  public isEmpty(): boolean { return !this._owned; }\n\n  /** When the holder is disposed, it disposes the held object if any. */\n  public dispose(): void { this.clear(); }\n\n  /** Stop listening for the disposal of this._owned. */\n  private _unlisten() {\n    const disposalListener = this._disposalListener;\n    if (disposalListener) {\n      this._disposalListener = undefined;\n      disposalListener.dispose();\n    }\n  }\n\n  private _onOutsideDispose() {\n    this._disposalListener = undefined;\n    this._owned = null;\n  }\n}\n\n/**\n * MultiHolder keeps multiple disposable object. It disposes all held object when the holder\n * itself is disposed. It's actually nothing more than the Disposable base class itself, just\n * exposed with a clearer name that describes its purpose.\n */\nexport class MultiHolder extends Disposable {}\n\n/**\n * Sets owner of obj (i.e. calls owner.autoDispose(obj)) unless owner is null. Returns obj.\n */\nexport function setDisposeOwner<T extends IDisposable>(owner: IDisposableOwnerT<T>|null, obj: T): T {\n  if (owner) { owner.autoDispose(obj); }\n  return obj;\n}\n\n/**\n * Helper for reporting errors during disposal. Try to report the type of the object.\n */\nfunction _describe(obj: any) {\n  return (obj && obj.constructor && obj.constructor.name ? obj.constructor.name : '' + obj);\n}\n\n/**\n * DisposalList is an internal class mimicking emit.Emitter. The difference is that callbacks are\n * called in reverse order, and exceptions in callbacks are reported and swallowed.\n */\nclass DisposalList extends LLink {\n  constructor() { super(); }\n\n  public addListener<T>(callback: (this: T) => void, optContext?: T): DisposeListener {\n    const lis = new DisposeListener(callback, optContext);\n    this._insertBefore(this._next!, lis);\n    return lis;\n  }\n\n  /**\n   * Call all callbacks and dispose this object. The owner is required for better reporting of\n   * errors if any callback throws.\n   */\n  public callAndDispose(owner: Disposable): void {\n    try {\n      DisposeListener.callAll(this._next!, this, owner);\n    } finally {\n      this._disposeList();\n    }\n  }\n}\n\n/**\n * Internal class that keeps track of one item of the DisposalList. It mimicks emit.Listener, but\n * reports and swallows erros when it calls the callbacks in the list.\n */\nclass DisposeListener extends LLink implements IDisposable {\n  public static callAll(begin: LLink, end: LLink, owner: Disposable): void {\n    while (begin !== end) {\n      const lis = begin as DisposeListener;\n      try {\n        lis.callback.call(lis.context);\n      } catch (e) {\n        // tslint:disable-next-line:no-console\n        console.error(\"While disposing %s, error disposing %s: %s\", _describe(owner), _describe(this), e);\n      }\n      begin = lis._next!;\n    }\n  }\n\n  constructor(private callback: () => void, private context?: any) { super(); }\n\n  public dispose(): void {\n    if (this.isDisposed()) { return; }\n    this._removeNode(this);\n  }\n}\n","/**\n * dom.js provides a way to build a DOM tree easily.\n *\n * E.g.\n *  import {dom} from 'grainjs';\n *  dom('a#link.c1.c2', {'href': url}, 'Hello ', dom('span', 'world'));\n *    creates Node <a id=\"link\" class=\"c1 c2\" href={{url}}Hello <span>world</span></a>.\n *\n *  dom.frag(dom('span', 'Hello'), ['blah', dom('div', 'world')])\n *    creates document fragment with <span>Hello</span>blah<div>world</div>.\n *\n * DOM can also be created and modified inline during creation:\n *  dom('a#id.c1',\n *      dom.cls('c2'), dom.attr('href', url),\n *      dom.text('Hello '), dom('span', dom.text('world')))\n *    creates Node <a id=\"link\" class=\"c1 c2\" href={{url}}Hello <span>world</span></a>,\n *    identical to the first example above.\n */\n\n// We keep various dom-related functions organized in private modules, but they are exposed here.\nexport * from './domImpl';\nexport * from './domComponent';\nexport * from './domComputed';\nexport * from './domDispose';\nexport * from './domForEach';\nexport * from './domMethods';\nexport * from './domevent';\n\nimport * as _domComponent from './domComponent';\nimport * as _domComputed from './domComputed';\nimport * as _domDispose from './domDispose';\nimport * as _domForEach from './domForEach';\nimport * as _domImpl from './domImpl';\nimport * as _domMethods from './domMethods';\n\nimport * as domevent from './domevent';\n\nimport {dom as _dom, IDomArgs, TagElem, TagName} from './domImpl';\n\n// We just want to re-export _domImpl.dom, but to allow adding methods to it in a typesafe way,\n// TypeScript wants us to declare a real function in the same file.\nexport function dom<Tag extends TagName>(tagString: Tag, ...args: IDomArgs<TagElem<Tag>>): TagElem<Tag> {\n  return _dom(tagString, ...args);\n}\n\n// Additionally export all methods as properties of dom() function.\nexport namespace dom {      // tslint:disable-line:no-namespace\n  export const svg             = _domImpl.svg;\n  export const frag            = _domImpl.frag;\n  export const update          = _domImpl.update;\n  export const find            = _domImpl.find;\n  export const findAll         = _domImpl.findAll;\n\n  export const domDispose      = _domDispose.domDispose;\n  export const onDisposeElem   = _domDispose.onDisposeElem;\n  export const onDispose       = _domDispose.onDispose;\n  export const autoDisposeElem = _domDispose.autoDisposeElem;\n  export const autoDispose     = _domDispose.autoDispose;\n\n  export const attrsElem       = _domMethods.attrsElem;\n  export const attrs           = _domMethods.attrs;\n  export const attrElem        = _domMethods.attrElem;\n  export const attr            = _domMethods.attr;\n  export const boolAttrElem    = _domMethods.boolAttrElem;\n  export const boolAttr        = _domMethods.boolAttr;\n  export const textElem        = _domMethods.textElem;\n  export const text            = _domMethods.text;\n  export const styleElem       = _domMethods.styleElem;\n  export const style           = _domMethods.style;\n  export const propElem        = _domMethods.propElem;\n  export const prop            = _domMethods.prop;\n  export const showElem        = _domMethods.showElem;\n  export const show            = _domMethods.show;\n  export const hideElem        = _domMethods.hideElem;\n  export const hide            = _domMethods.hide;\n  export const clsElem         = _domMethods.clsElem;\n  export const cls             = _domMethods.cls;\n  export const clsPrefix       = _domMethods.clsPrefix;\n  export const dataElem        = _domMethods.dataElem;\n  export const data            = _domMethods.data;\n  export const getData         = _domMethods.getData;\n  export const replaceContent  = _domComputed.replaceContent;\n  export const domComputed     = _domComputed.domComputed;\n  export const maybe           = _domComputed.maybe;\n\n  export const forEach         = _domForEach.forEach;\n\n  export const create          = _domComponent.create;\n\n  export const onElem          = domevent.onElem;\n  export const on              = domevent.on;\n  export const onMatchElem     = domevent.onMatchElem;\n  export const onMatch         = domevent.onMatch;\n  export const onKeyElem       = domevent.onKeyElem;\n  export const onKeyPress      = domevent.onKeyPress;\n  export const onKeyDown       = domevent.onKeyDown;\n}\n","/**\n * UI components that can be inserted into dom().\n *\n * Components are created and inserted using dom.create():\n *\n *    dom('div',\n *      dom.create(MyWidget, ...myArgs),        // Calls MyWidget.create(owner, ...myArgs)\n *      dom.create(createMyWidget, ...myArgs),  // Calls createMyWidget(owner, ...myArgs)\n *    )\n *\n * The first argument may be a function, which is called directly, or a class with a .create()\n * static method, in which case that's what gets called.\n *\n * In both cases, the call gets a first argument of `owner` followed by the rest of the arguments\n * to dom.create(). The `owner` is a MultiHolder that will own this component. This works\n * naturally with any class that derives from Disposable, since it then has a suitable static\n * create() method.\n *\n * Function-based components may use owner to easily handle disposal. For example:\n *\n *    dom.create(createMyWidget)\n *    function createMyWidget(owner) {\n *      const foo = Foo.create(owner);\n *      return dom('div', foo.getTitle());\n *    }\n *\n * The `owner` argument is the main benefit of dom.create(). Logically, the owner is the DOM where\n * the component is attached. When the parent DOM element is disposed, so is the component.\n *\n *    [Explanation] To understand why the syntax is such, consider a potential alternative such as:\n *\n *       dom('div', _insert_(new Comp1()), _insert_(new Comp2(...args)))\n *\n *    In both cases, the constructor for Comp1 runs before the constructor for Comp2. What happens\n *    when Comp2's constructor throws an exception? In the second case, nothing yet owns the\n *    created Comp1 component, and it will never get cleaned up. With dom.create(), the DOM\n *    gets ownership of Comp1 early enough and will dispose it.\n *\n * A function component may return DOM directly. A class component returns the class instance,\n * which must have a .buildDom() method which will be called right after the constructor to get\n * the DOM. Note that buildDom is only called once.\n *\n * A function component may also return an object with .buildDom(). So these are equivalent:\n *\n *    dom.create(MyWidget)\n *    dom.create((owner) => MyWidget.create(owner))\n *\n * Note that ownership should be handled using the `owner` argument. Don't do this:\n *\n *    // NON-EXAMPLE: Nothing will dispose the created object:\n *    // dom.create(() => new MyWidget());\n *\n * The returned DOM may includes Nodes, strings, and domComputed() values, as well as arrays of\n * any of these. In other words, any DomArg goes except DomMethods. All the DOM returned will be\n * disposed when the containing element is disposed, followed by the `owner` itself.\n */\nimport {MultiHolder} from './dispose';\nimport {domComputed, DomComputed} from './domComputed';\nimport {autoDisposeElem} from './domDispose';\n\nexport type DomContents = Node | string | DomComputed | void | null | undefined | IDomContentsArray;\nexport interface IDomContentsArray extends Array<DomContents> {}\n\nexport interface IDomComponent {\n  buildDom(): DomContents;\n}\n\nexport type DomComponentReturn = DomContents | IDomComponent;\n\nexport type IDomCreateFunc<Args extends any[]> = (owner: MultiHolder, ...args: Args) => DomComponentReturn;\n\n// It's not that we must have a constructor matching create(), but specifying type of new allows\n// type checking of classes that derive from Disposable, whereas matching only create() does not\n// (presumably because of the too much magic that Disposable does for the type of create()).\nexport interface IDomCreateClass<Args extends any[]> {\n  create: IDomCreateFunc<Args>;\n  new (...args: Args): DomComponentReturn;\n}\nexport type IDomCreator<Args extends any[]> = IDomCreateFunc<Args> | IDomCreateClass<Args>;\n\ntype DomCreatorArgs<T> =\n  T extends (owner: MultiHolder, ...args: infer P) => any ? P :\n  (T extends new (...args: infer P) => any ? P : never);\n\nexport function create<Fn extends IDomCreator<any[]>>(fn: Fn, ...args: DomCreatorArgs<Fn>): DomContents {\n  const [markerPre, markerPost, func] = domComputed(null, () => {\n    // Note that the callback to domComputed() is not called until the markers have been attached\n    // to the parent element. We attach the MultiHolder's disposal to markerPost the way\n    // domComputed() normally attaches its own bindings.\n    const owner = MultiHolder.create(null);\n    autoDisposeElem(markerPost, owner);\n\n    const value: DomComponentReturn = ('create' in fn) ?\n      (fn as IDomCreateClass<any[]>).create(owner, ...args) :\n      (fn as IDomCreateFunc<any[]>)(owner, ...args);\n    return (value && typeof value === 'object' && 'buildDom' in value) ?\n      value.buildDom() : value;\n  });\n  return [markerPre, markerPost, func];\n}\n","import {BindableValue, subscribeElem} from './binding';\nimport {domDispose} from './domDispose';\nimport {DomArg, DomMethod, frag} from './domImpl';\n\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nimport {G} from './browserGlobals';\n\n// The type returned by domComputed(). It's actually an example of DomArg, but is given its own\n// name for use in places where a DomComputed is suitable but a general DomArg is not.\nexport type DomComputed = [Node, Node, DomMethod];\n\n/**\n * Replaces the content between nodeBefore and nodeAfter, which should be two siblings within the\n * same parent node. New content may be anything allowed as an argument to dom(), including null\n * to insert nothing. Runs disposers, if any, on all removed content.\n */\nexport function replaceContent(nodeBefore: Node, nodeAfter: Node, content: DomArg): void {\n  const elem = nodeBefore.parentNode;\n  if (elem) {\n    let next;\n    for (let n = nodeBefore.nextSibling; n && n !== nodeAfter; n = next) {\n      next = n.nextSibling;\n      domDispose(n);\n      elem.removeChild(n);\n    }\n    if (content) {\n      elem.insertBefore(content instanceof G.Node ? content : frag(content), nodeAfter);\n    }\n  }\n}\n\n/**\n * Appends dynamic DOM content to an element. The value may be an observable or function (from\n * which a computed is created), whose value will be passed to `contentFunc` which should return\n * DOM content. If the contentFunc is omitted, it defaults to identity, i.e. it's OK for the\n * observable or function to return DOM directly.\n *\n * The DOM content returned may be an element, string, array, or null. Whenever the observable\n * changes, previous content is disposed and removed, and new content added in its place.\n *\n * The following are roughly equivalent:\n *  (A) domComputed(nlinesObs, nlines => nlines > 1 ? dom('textarea') : dom('input'));\n *  (B) domComputed(use => use(nlinesObs) > 1 ? dom('textarea') : dom('input'));\n *  (C) domComputed(use => use(nlinesObs) > 1, isTall => isTall ? dom('textarea') : dom('input'));\n *\n * Here, (C) is best. Both (A) and (B) would rebuild DOM for any change in nlinesObs, but (C)\n * encapsulates meaningful changes in the observable, and only recreates DOM when necessary.\n *\n * Syntax (B), without the second argument, may be useful in cases of DOM depending on several\n * observables, e.g.\n *\n *    domComputed(use => use(readonlyObs) ? dom('div') :\n *                          (use(nlinesObs) > 1 ? dom('textarea') : dom('input')));\n *\n * If the argument is not an observable, domComputed() may but should not be used. The following\n * are equivalent:\n *\n *    dom(..., domComputed(listValue, list => `Have ${list.length} items`), ...)\n *    dom(..., `Have ${listValue.length} items`, ...)\n *\n * In this case, the latter is preferred as the clearly simpler one.\n *\n * @param valueObs: Observable or function for a computed.\n * @param contentFunc: Function called with the result of valueObs as the input, and\n *    returning DOM as output. If omitted, defaults to the identity function.\n */\n// Note that DomMethod is excluded because it prevents typescript from inferring the type of\n// the first argument when it's a function (and it's not useful).\nexport function domComputed(valueObs: BindableValue<Exclude<DomArg, DomMethod>>): DomComputed;\nexport function domComputed<T>(valueObs: BindableValue<T>, contentFunc: (val: T) => DomArg): DomComputed;\nexport function domComputed<T>(\n  valueObs: BindableValue<T>, contentFunc: (val: T) => DomArg = identity as any,\n): DomComputed {\n  const markerPre = G.document.createComment('a');\n  const markerPost = G.document.createComment('b');\n\n  // Function is added after markerPre and markerPost, so that it runs once they have already been\n  // attached to elem (the parent element).\n  return [markerPre, markerPost, (elem: Node) => {\n    subscribeElem(markerPost, valueObs,\n      (value) => replaceContent(markerPre, markerPost, contentFunc(value)));\n  }];\n}\n\nfunction identity<T>(arg: T): T { return arg; }\n\n/**\n * Conditionally appends DOM to an element. The value may be an observable or function (from which\n * a computed is created), whose value -- if truthy -- will be passed to `contentFunc` which\n * should return DOM content. If the value is falsy, DOM content is removed.\n *\n * Note that if the observable changes between different truthy values, contentFunc gets called\n * for each value, and previous content gets destroyed. To consider all truthy values the same,\n * use an observable that returns a proper boolean, e.g.\n *\n *    dom.maybe(use => Boolean(use(fooObs)), () => dom(...));\n *\n * As with domComputed(), dom.maybe() may but should not be used when the argument is not an\n * observable or function. The following are equivalent:\n *\n *    dom(..., dom.maybe(myValue, () => dom(...)));\n *    dom(..., myValue ? dom(...) : null);\n *\n * The latter is preferred for being simpler.\n *\n * @param boolValueObs: Observable or function for a computed.\n * @param contentFunc: Called with the result of boolValueObs when it is truthy. Should return DOM.\n */\nexport function maybe<T>(boolValueObs: BindableValue<T>, contentFunc: (val: NonNullable<T>) => DomArg): DomComputed {\n  return domComputed(boolValueObs, (value) => value ? contentFunc(value!) : null);\n}\n","import {IDisposable} from './dispose';\n\n/**\n * Private global disposal map. It maintains the association between DOM nodes and cleanup\n * functions added with dom.onDispose(). To support multiple disposers on one element, we use a\n * WeakMap-based linked list:\n *\n *    _disposeMap[elem] = disposer2;\n *    _disposeMap[disposer2] = disposer1;\n *    etc.\n *\n * This avoids allocating arrays or using undeclared properties for a different linked list.\n */\nconst _disposeMap: WeakMap<Node|INodeFunc, INodeFunc> = new WeakMap();\n\nexport type INodeFunc = (node: Node) => void;\n\n// Internal helper to walk the DOM tree, calling visitFunc(elem) on all descendants of elem.\n// Descendants are processed first.\nfunction _walkDom(elem: Node, visitFunc: INodeFunc): void {\n  let c: Node|null = elem.firstChild;\n  while (c) {\n    // Note: this might be better done using an explicit stack, but in practice DOM trees aren't\n    // so deep as to cause problems.\n    _walkDom(c, visitFunc);\n    c = c.nextSibling;\n  }\n  visitFunc(elem);\n}\n\n// Internal helper to run all disposers for a single element.\nexport function _disposeNode(node: Node): void {\n  let disposer = _disposeMap.get(node);\n  if (disposer) {\n    let key: Node|INodeFunc = node;\n    do {\n      _disposeMap.delete(key);\n      disposer(node);\n      // Find the next disposer; these are chained when there are multiple.\n      key = disposer;\n      disposer = _disposeMap.get(key);\n    } while (disposer);\n  }\n}\n\nfunction _disposeNodeRecursive(node: Node): void {\n  _walkDom(node, domDisposeHooks.disposeNode);\n}\n\nexport interface IDomDisposeHooks {\n  disposeRecursive: (node: Node) => void;\n  disposeNode: (node: Node) => void;\n}\n\n/**\n * Support for extending dom disposal. This is very low-level, and needs utmost care. Any\n * disposers set should take care of calling the original versions of the disposers.\n */\nexport const domDisposeHooks: IDomDisposeHooks = {\n  disposeNode: _disposeNode,\n  disposeRecursive: _disposeNodeRecursive,\n};\n\n/**\n * Run disposers associated with any descendant of elem or with elem itself. Disposers get\n * associated with elements using dom.onDispose(). Descendants are processed first.\n *\n * It is automatically called if one of the function arguments to dom() throws an exception during\n * element creation. This way any onDispose() handlers set on the unfinished element get called.\n *\n * @param {Node} node: The element to run disposers on.\n */\nexport function domDispose(node: Node): void {\n  domDisposeHooks.disposeRecursive(node);\n}\n\n/**\n * Associate a disposerFunc with a DOM element. It will be called when the element is disposed\n * using domDispose() on it or any of its parents. If onDispose is called multiple times, all\n * disposerFuncs will be called in reverse order.\n * @param {Element} elem: The element to associate the disposer with.\n * @param {Function} disposerFunc(elem): Will be called when domDispose() is called on the\n *    element or its ancestor.\n * Note that it is not necessary usually to dispose event listeners attached to an element (e.g.\n * with dom.on()) since their lifetime is naturally limited to the lifetime of the element.\n */\nexport function onDisposeElem(elem: Node, disposerFunc: INodeFunc): void {\n  const prevDisposer = _disposeMap.get(elem);\n  _disposeMap.set(elem, disposerFunc);\n  if (prevDisposer) {\n    _disposeMap.set(disposerFunc, prevDisposer);\n  }\n}\nexport function onDispose(disposerFunc: INodeFunc) {\n  return (elem: Node) => onDisposeElem(elem, disposerFunc);\n}\n\n/**\n * Make the given element own the disposable, and call its dispose method when domDispose() is\n * called on the element or any of its parents.\n * @param {Element} elem: The element to own the disposable.\n * @param {Disposable} disposable: Anything with a .dispose() method.\n */\nexport function autoDisposeElem(elem: Node, disposable: IDisposable|null) {\n  if (disposable) {\n    onDisposeElem(elem, () => disposable.dispose());\n  }\n}\nexport function autoDispose(disposable: IDisposable|null) {\n  if (disposable) {\n    return (elem: Node) => autoDisposeElem(elem, disposable);\n  }\n}\n","import {replaceContent} from './domComputed';\nimport {autoDisposeElem, domDispose} from './domDispose';\nimport {DomMethod, frag} from './domImpl';\nimport {computedArray, MaybeObsArray, ObsArray} from './obsArray';\n\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nimport {G} from './browserGlobals';\n\n/**\n * Creates DOM elements for each element of an observable array. As the array is changed, children\n * are added or removed. This works for any array-valued observable, and for obsArray() and\n * computedArray() it works more efficiently for simple changes.\n *\n * The given itemCreateFunc() should return a single DOM node for each item, or null to skip that\n * item. It is called for new items whenever they are spliced in, or the array replaced. The\n * forEach() owns the created nodes, and runs domDispose() on them when they are spliced out.\n *\n * If the created nodes are removed from their parent externally, forEach() will cope with it, but\n * will consider these elements as no longer owned, and will not run domDispose() on them.\n *\n * Note that itemCreateFunc() does not receive an index: an index would only be correct at the\n * time the item is created, and would not reflect further changes to the array.\n *\n * If you'd like to map the DOM node back to its source item, use dom.data() and dom.getData() in\n * itemCreateFunc().\n */\nexport function forEach<T>(obsArray: MaybeObsArray<T>, itemCreateFunc: (item: T) => Node|null): DomMethod {\n  return (elem: Node) => {\n    const markerPre = G.document.createComment('a');\n    const markerPost = G.document.createComment('b');\n    elem.appendChild(markerPre);\n    elem.appendChild(markerPost);\n\n    if (Array.isArray(obsArray)) {\n      replaceContent(markerPre, markerPost, obsArray.map(itemCreateFunc));\n      return;\n    }\n\n    const nodes: ObsArray<Node|null> = computedArray(obsArray, itemCreateFunc);\n\n    // Be sure to dispose the newly-created array when the DOM it's associated with is gone.\n    autoDisposeElem(markerPost, nodes);\n\n    nodes.addListener((newArr: Array<Node|null>, oldArr: Array<Node|null>, splice?) => {\n      if (splice) {\n        // Remove the elements that are gone.\n        for (const node of splice.deleted) {\n          if (node && node.parentNode === elem) {\n            domDispose(node);\n            elem.removeChild(node);\n          }\n        }\n\n        if (splice.numAdded > 0) {\n          // Find a valid child immediately following the spliced out portion, for DOM insertion.\n          const endIndex: number = splice.start + splice.numAdded;\n          let nextElem: Node = markerPost;\n          for (let i = endIndex; i < newArr.length; i++) {\n            const node = newArr[i];\n            if (node && node.parentNode === elem) {\n              nextElem = node;\n              break;\n            }\n          }\n\n          // Insert the new elements.\n          const content = frag(newArr.slice(splice.start, endIndex));\n          elem.insertBefore(content, nextElem);\n        }\n      } else {\n        replaceContent(markerPre, markerPost, newArr);\n      }\n    });\n    replaceContent(markerPre, markerPost, nodes.get());\n  };\n}\n","import {domDispose} from './domDispose';\nimport {attrsElem} from './domMethods';\n\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nimport {G} from './browserGlobals';\n\n// For inline modifications, some other options were considered:\n// (1) Chainable methods (to use e.g. `dom('div').attr('href', url).value()`). This approach is\n//     criticized here:\n//     https://medium.com/making-internets/why-using-chain-is-a-mistake-9bc1f80d51ba\n// (2) Adding methods to DOM (to use e.g. `dom('div').attr('href', url)`. This is criticized here:\n//     http://perfectionkills.com/whats-wrong-with-extending-the-dom/\n// The approach chosen (inline modifications using functions that are typically bound on the fly)\n// is more flexible and robust, and only suffers from slightly more verbosity. E.g.\n// `dom('div', dom.attr('href', url))`.\n\nexport type DomMethod<T = Node> = (elem: T) => DomArg<T>|void;\nexport type DomElementMethod = DomMethod<HTMLElement>;\n\nexport interface IAttrObj {\n  [attrName: string]: string|boolean|null|undefined;\n}\n\n// Type of argument to dom-building functions. Allows IAttrObj when applied to an Element.\n//\n// Note that DomArg<A> differs from DomArg<B> in what callbacks are accepted, so DomArg<Element>\n// can be assigned to DomArg<HTMLInputElement>, but not vice versa. When writing a function that\n// accepts DomArgs and applies them to an element, use the most specific DomArg type that works\n// for that element, e.g. DomArg<HTMLInputElement> if possible, then DomElementArg, then DomArg.\nexport type DomArg<T = Node> = Node | string | void | null | undefined |\n  IDomArgs<T> | DomMethod<T> | (T extends Element ? IAttrObj : never);\n\nexport interface IDomArgs<T = Node> extends Array<DomArg<T>> {}\n\n// Alias for backward compatibility.\nexport type DomElementArg = DomArg<HTMLElement>;\n\n// The goal of the above declarations is to get help from TypeScript in detecting incorrect usage:\n// (See test/types/dom.ts for a test of this.)\n//  import {text, hide} from './domMethods';\n//  dom('div', text('hello'));        // OK\n//  dom('div', hide(true));           // OK\n//  dom('div', {title: 'hello'});     // OK\n//  frag(text('hello'));              // OK\n//  frag(hide(true));                 // Bad: DocumentFragment is not an Element\n//  frag({title: 'hello'});           // Bad: DocumentFragment is not an Element\n\n/**\n * dom('tag#id.class1.class2', ...args)\n *   The first argument is a string consisting of a tag name, with optional #foo suffix\n *   to add the ID 'foo', and zero or more .bar suffixes to add a CSS class 'bar'.\n *\n *   NOTE that better typings are available when a tag is used directly, e.g.\n *      dom('input', {id: 'foo'}, (elem) => ...) --> elem has type HTMLInputElement\n *      dom('input#foo',          (elem) => ...) --> elem has type HTMLElement\n *\n * The rest of the arguments are optional and may be:\n *\n *   Nodes - which become children of the created element;\n *   strings - which become text node children;\n *   objects - of the form {attr: val} to set additional attributes on the element;\n *   Arrays - which are flattened with each item processed recursively;\n *   functions - which are called with elem as the argument, for a chance to modify the\n *       element as it's being created. Return values are processed recursively.\n *   \"dom methods\" - expressions such as `dom.attr('href', url)` or `dom.hide(obs)`, which\n *       are actually special cases of the \"functions\" category.\n */\nexport function dom<Tag extends TagName>(tagString: Tag, ...args: IDomArgs<TagElem<Tag>>): TagElem<Tag> {\n  return _updateWithArgsOrDispose(_createFromTagString(_createElementHtml, tagString) as TagElem<Tag>, args);\n}\n\nexport type TagName = keyof HTMLElementTagNameMap|string;\nexport type TagElem<T extends TagName> = T extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[T] : HTMLElement;\n\n/**\n * svg('tag#id.class1.class2', ...args)\n *  Same as dom(...), but creates an SVG element.\n */\nexport function svg(tagString: string, ...args: IDomArgs<SVGElement>): SVGElement {\n  return _updateWithArgsOrDispose(_createFromTagString(_createElementSvg, tagString), args);\n}\n\n// Internal helper used to create HTML elements.\nfunction _createElementHtml(tag: string): HTMLElement {\n  return G.document.createElement(tag);\n}\n\n// Internal helper used to create SVG elements.\nfunction _createElementSvg(tag: string): SVGElement {\n  return G.document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n}\n\n/**\n * Internal helper to parse tagString, create an element using createFunc with the given tag, and\n * set its id and classes from the tagString.\n * @param {Funtion} createFunc(tag): Function that should create an element given a tag name.\n *    It is passed in to allow creating elements in different namespaces (e.g. plain HTML vs SVG).\n * @param {String} tagString: String of the form \"tag#id.class1.class2\" where id and classes are\n *    optional.\n * @return {Element} The result of createFunc(), possibly with id and class attributes also set.\n */\nfunction _createFromTagString<E extends Element>(createFunc: (tag: string) => E, tagString: string): E {\n  // We do careful hand-written parsing rather than use a regexp for speed. Using a regexp is\n  // significantly more expensive.\n  let tag: string;\n  let id: string|undefined;\n  let classes: string|undefined;\n  let dotPos: number = tagString.indexOf(\".\");\n  const hashPos: number = tagString.indexOf('#');\n  if (dotPos === -1) {\n    dotPos = tagString.length;\n  } else {\n    classes = tagString.substring(dotPos + 1).replace(/\\./g, ' ');\n  }\n  if (hashPos === -1) {\n    tag = tagString.substring(0, dotPos);\n  } else if (hashPos > dotPos) {\n    throw new Error(`ID must come before classes in dom(\"${tagString}\")`);\n  } else {\n    tag = tagString.substring(0, hashPos);\n    id = tagString.substring(hashPos + 1, dotPos);\n  }\n\n  const elem: E = createFunc(tag);\n  if (id) { elem.setAttribute('id', id); }\n  if (classes) { elem.setAttribute('class', classes); }\n  return elem;\n}\n\n/**\n * Update an element with any number of arguments, as documented in dom().\n */\nexport function update<T extends Node, Args extends IDomArgs<T>>(elem: T, ...args: Args): T {\n  return _updateWithArgs(elem, args);\n}\n\n/**\n * Update an element with an array of arguments.\n */\nfunction _updateWithArgs<T extends Node>(elem: T, args: IDomArgs<T>): T {\n  for (const arg of args) {\n    _updateWithArg(elem, arg);\n  }\n  return elem;\n}\n\n/**\n * Update an element with an array of arguments, calling disposers in case of an exception. It is\n * an internal helper to be used whenever elem is a newly-created element. If elem is an existing\n * element which the user already knows about, then _updateWithArgs should be called.\n */\nfunction _updateWithArgsOrDispose<T extends Node>(elem: T, args: IDomArgs<T>): T {\n  try {\n    return _updateWithArgs(elem, args);\n  } catch (e) {\n    domDispose(elem);\n    throw e;\n  }\n}\n\nfunction _updateWithArg<T extends Node>(elem: T, arg: DomArg<T>): void {\n  if (typeof arg === 'function') {\n    const value: DomArg<T> = arg(elem);\n    // Skip the recursive call in the common case when the function returns nothing.\n    if (value !== undefined && value !== null) {\n      _updateWithArg(elem, value);\n    }\n  } else if (Array.isArray(arg)) {\n    _updateWithArgs(elem, arg);\n  } else if (arg === undefined || arg === null) {\n    // Nothing to do.\n  } else if (arg instanceof G.Node) {\n    elem.appendChild(arg);\n  } else if (typeof arg === 'object') {\n    attrsElem(elem as any, arg);\n  } else {\n    elem.appendChild(G.document.createTextNode(arg));\n  }\n}\n\n/**\n * Creates a DocumentFragment processing arguments the same way as the dom() function.\n */\nexport function frag(...args: IDomArgs<DocumentFragment>): DocumentFragment {\n  const elem = G.document.createDocumentFragment();\n  return _updateWithArgsOrDispose<DocumentFragment>(elem, args);\n}\n\n/**\n * Find the first element matching a selector; just an abbreviation for document.querySelector().\n */\nexport function find(selector: string) { return G.document.querySelector(selector); }\n\n/**\n * Find all elements matching a selector; just an abbreviation for document.querySelectorAll().\n */\nexport function findAll(selector: string) { return G.document.querySelectorAll(selector); }\n","import {BindableValue, subscribeElem as _subscribe} from './binding';\nimport {onDisposeElem} from './domDispose';\nimport {DomElementMethod, DomMethod, IAttrObj} from './domImpl';\n\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nimport {G} from './browserGlobals';\n\n/**\n * Private global map for associating arbitrary data with DOM. It's a WeakMap, so does not prevent\n * values from being garbage collected when the owning DOM elements are no longer used.\n */\nconst _dataMap: WeakMap<Node, {[key: string]: any}> = new WeakMap();\n\n/**\n * Sets multiple attributes of a DOM element. The `attrs()` variant takes no `elem` argument.\n * Null and undefined values are omitted, and booleans are either omitted or set to empty string.\n * @param {Object} attrsObj: Object mapping attribute names to attribute values.\n */\nexport function attrsElem(elem: Element, attrsObj: IAttrObj): void {\n  for (const key of Object.keys(attrsObj)) {\n    const val = attrsObj[key];\n    if (val != null && val !== false) {\n      elem.setAttribute(key, val === true ? '' : val);\n    }\n  }\n}\nexport function attrs(attrsObj: IAttrObj): DomElementMethod {\n  return (elem) => attrsElem(elem, attrsObj);\n}\n\n/**\n * Sets an attribute of a DOM element to the given value. Removes the attribute when the value is\n * null or undefined. The `attr()` variant takes no `elem` argument, and `attrValue` may be an\n * observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} attrName: The name of the attribute to bind, e.g. 'href'.\n * @param {String|null} attrValue: The string value or null to remove the attribute.\n */\nexport function attrElem(elem: Element, attrName: string, attrValue: string|null): void {\n  if (attrValue === null || attrValue === undefined) {\n    elem.removeAttribute(attrName);\n  } else {\n    elem.setAttribute(attrName, attrValue);\n  }\n}\nexport function attr(attrName: string, attrValueObs: BindableValue<string>): DomElementMethod {\n  return (elem) => _subscribe(elem, attrValueObs, (val) => attrElem(elem, attrName, val));\n}\n\n/**\n * Sets or removes a boolean attribute of a DOM element. According to the spec, empty string is a\n * valid true value for the attribute, and the false value is indicated by the attribute's absence.\n * The `boolAttr()` variant takes no `elem`, and `boolValue` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} attrName: The name of the attribute to bind, e.g. 'checked'.\n * @param {Boolean} boolValue: Boolean value whether to set or unset the attribute.\n */\nexport function boolAttrElem(elem: Element, attrName: string, boolValue: boolean): void {\n  attrElem(elem, attrName, boolValue ? '' : null);\n}\nexport function boolAttr(attrName: string, boolValueObs: BindableValue<boolean>): DomElementMethod {\n  return (elem) => _subscribe(elem, boolValueObs, (val) => boolAttrElem(elem, attrName, val));\n}\n\n/**\n * Adds a text node to the element. The `text()` variant takes no `elem`, and `value` may be an\n * observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} value: The text value to add.\n */\nexport function textElem(elem: Node, value: string): void {\n  elem.appendChild(G.document.createTextNode(value));\n}\nexport function text(valueObs: BindableValue<string>): DomMethod {\n  return (elem) => {\n    const textNode = G.document.createTextNode('');\n    _subscribe(elem, valueObs, (val) => { textNode.nodeValue = val; });\n    elem.appendChild(textNode);\n  };\n}\n\n/**\n * Sets a style property of a DOM element to the given value. The `style()` variant takes no\n * `elem`, and `value` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} property: The name of the style property to update, e.g. 'fontWeight'.\n * @param {String} value: The value for the property.\n */\nexport function styleElem(elem: Element, property: string, value: string): void {\n  (elem as any).style[property] = value;\n}\nexport function style(property: string, valueObs: BindableValue<string>): DomElementMethod {\n  return (elem) =>\n    _subscribe(elem, valueObs, (val) => styleElem(elem, property, val));\n}\n\n/**\n * Sets the property of a DOM element to the given value.\n * The `prop()` variant takes no `elem`, and `value` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} property: The name of the property to update, e.g. 'disabled'.\n * @param {Object} value: The value for the property.\n */\nexport function propElem<T>(elem: Node, property: string, value: T): void {\n  (elem as any)[property] = value;\n}\nexport function prop<T>(property: string, valueObs: BindableValue<T>): DomMethod {\n  return (elem) => _subscribe(elem, valueObs, (val) => propElem(elem, property, val));\n}\n\n/**\n * Shows or hides the element depending on a boolean value. Note that the element must be visible\n * initially (i.e. unsetting style.display should show it).\n * The `show()` variant takes no `elem`, and `boolValue` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {Boolean} boolValue: True to show the element, false to hide it.\n */\nexport function showElem(elem: HTMLElement, boolValue: boolean): void {\n  elem.style.display = boolValue ? '' : 'none';\n}\nexport function show(boolValueObs: BindableValue<boolean>): DomElementMethod {\n  return (elem) =>\n    _subscribe(elem, boolValueObs, (val) => showElem(elem, val));\n}\n\n/**\n * The opposite of show, hiding the element when boolValue is true.\n * The `hide()` variant takes no `elem`, and `boolValue` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {Boolean} boolValue: True to hide the element, false to show it.\n */\nexport function hideElem(elem: HTMLElement, boolValue: boolean): void {\n  elem.style.display = boolValue ? 'none' : '';\n}\nexport function hide(boolValueObs: BindableValue<boolean>): DomElementMethod {\n  return (elem) =>\n    _subscribe(elem, boolValueObs, (val) => hideElem(elem, val));\n}\n\n/**\n * Sets or toggles the given css class className.\n */\nexport function clsElem(elem: Element, className: string, boolValue: boolean = true): void {\n  elem.classList.toggle(className, Boolean(boolValue));\n}\n\n/**\n * Sets or toggles a css class className. If className is an observable, it will be replaced when\n * the observable changes. If a plain string, then an optional second boolean observable may be\n * given, which will toggle it.\n *\n *    dom.cls('foo')                                // Sets className 'foo'\n *    dom.cls('foo', isFoo);                        // Toggles 'foo' className according to observable.\n *    dom.cls('foo', (use) => use(isFoo));          // Toggles 'foo' className according to observable.\n *    dom.cls(fooClass);                            // Sets className to the value of fooClass observable\n *    dom.cls((use) => `prefix-${use(fooClass)}`);  // Sets className to prefix- plus fooClass observable.\n */\nexport function cls(className: string, boolValue?: BindableValue<boolean>): DomElementMethod;\nexport function cls(className: BindableValue<string>): DomElementMethod;\nexport function cls(className: string|BindableValue<string>, boolValue?: BindableValue<boolean>): DomElementMethod {\n  if (typeof className !== 'string') {\n    return _clsDynamicPrefix('', className);\n  } else if (!boolValue || typeof boolValue === 'boolean') {\n    return (elem) => clsElem(elem, className, boolValue);\n  } else {\n    return (elem) => _subscribe(elem, boolValue, (val) => clsElem(elem, className, val));\n  }\n}\n\n/**\n * Just like cls() but prepends a prefix to className, including when it is an observable.\n */\nexport function clsPrefix(prefix: string, className: string, boolValue?: BindableValue<boolean>): DomElementMethod;\nexport function clsPrefix(prefix: string, className: BindableValue<string>): DomElementMethod;\nexport function clsPrefix(prefix: string, className: string|BindableValue<string>,\n                          boolValue?: BindableValue<boolean>): DomElementMethod {\n  if (typeof className !== 'string') {\n    return _clsDynamicPrefix(prefix, className);\n  } else {\n    return cls(prefix + className, boolValue);\n  }\n}\n\nfunction _clsDynamicPrefix(prefix: string, className: BindableValue<string>): DomElementMethod {\n  return (elem) => {\n    let prevClass: string|null = null;\n    _subscribe(elem, className, (name: string) => {\n      if (prevClass) { elem.classList.remove(prevClass); }\n      prevClass = name ? prefix + name : null;\n      if (prevClass) { elem.classList.add(prevClass); }\n    });\n  };\n}\n\n/**\n * Associate arbitrary data with a DOM element. The `data()` variant takes no `elem`, and `value`\n * may be an observable or function.\n * @param {Element} elem: The element with which to associate data.\n * @param {String} key: Key to identify this piece of data among others attached to elem.\n * @param {Object} value: Arbitrary value to associate with elem.\n */\nexport function dataElem(elem: Node, key: string, value: any): void {\n  const obj = _dataMap.get(elem);\n  if (obj) {\n    obj[key] = value;\n  } else {\n    onDisposeElem(elem, () => _dataMap.delete(elem));\n    _dataMap.set(elem, {[key]: value});\n  }\n}\nexport function data(key: string, valueObs: BindableValue<any>): DomMethod {\n  return (elem) => _subscribe(elem, valueObs, (val) => dataElem(elem, key, val));\n}\nexport function getData(elem: Node, key: string) {\n  const obj = _dataMap.get(elem);\n  return obj && obj[key];\n}\n\n/**\n * A very simple setup to identify DOM elements for testing purposes. Here's the recommended\n * usage.\n *\n *   // In the component to be tested.\n *   import {noTestId, TestId} from 'grainjs';\n *\n *   function myComponent(myArgs, testId: TestId = noTestId) {\n *     return dom(..., testId(\"some-name\"),\n *       dom(..., testId(\"another-name\"), ...),\n *     );\n *   }\n *\n * In the fixture code using this component:\n *\n *   import {makeTestId} from 'grainjs';\n *\n *   dom(..., myComponent(myArgs, makeTestId('test-mycomp-'), ...)\n *\n * In the webdriver test code:\n *\n *   driver.find('.test-my-comp-some-name')\n *   driver.find('.test-my-comp-another-name')\n *\n * When myComponent() is created with testId argument omitted, the testId() calls are no-ops. When\n * makeTestId('test-foo-') is passed in, testId() calls simply add a css class with that prefix.\n */\nexport type TestId = (name: string) => DomElementMethod|null;\n\n/**\n * See documentation for TestId above.\n */\nexport function makeTestId(prefix: string): TestId {\n  return clsPrefix.bind(null, prefix);\n}\n\n/**\n * See documentation for TestId above.\n */\nexport const noTestId: TestId = (name: string) => null;\n","/**\n * domevent provides a way to listen to DOM events, similar to JQuery's `on()` function. Its\n * methods are also exposed via the dom.js module, as `dom.on()`, etc.\n *\n * It is typically used as an argument to the dom() function:\n *\n *    dom('div', dom.on('click', (event, elem) => { ... }));\n *\n * When the div is disposed, the listener is automatically removed.\n *\n * The underlying interface to listen to an event is this:\n *\n *    let listener = dom.onElem(elem, 'click', (event, elem) => { ... });\n *\n * The callback is called with the event and the element to which it was attached. Unlike in\n * JQuery, the callback's return value is ignored. Use event.stopPropagation() and\n * event.preventDefault() explicitly if needed.\n *\n * To stop listening:\n *\n *    listener.dispose();\n *\n * Disposing the listener returned by .onElem() is the only way to stop listening to an event. You\n * can use autoDispose to stop listening automatically when subscribing in a Disposable object:\n *\n *    this.autoDispose(domevent.onElem(document, 'mouseup', callback));\n *\n * To listen to descendants of an element matching the given selector (what JQuery calls\n * \"delegated events\", see http://api.jquery.com/on/):\n *\n *    dom('div', dom.onMatch('.selector', 'click', (event, elem) => { ... }));\n * or\n *    let lis = domevent.onMatchElem(elem, '.selector', 'click', (event, el) => { ... });\n *\n * In this usage, the element passed to the callback will be a DOM element matching the given\n * selector. If there are multiple matches, the callback is only called for the innermost one.\n *\n * If you need to remove the callback on first call, here's a useful pattern:\n *    let lis = domevent.onElem(elem, 'mouseup', e => { lis.dispose(); other_work(); });\n */\n\nimport {IDisposable} from './dispose';\nimport {DomElementMethod, DomMethod} from './domImpl';\n\nexport type EventName = keyof HTMLElementEventMap;\nexport type EventType<E extends EventName|string> = E extends EventName ? HTMLElementEventMap[E] : Event;\n\nexport type EventCB<E extends Event = Event, T extends EventTarget = EventTarget> =\n  (this: void, event: E, elem: T) => void;\n\nfunction _findMatch(inner: Element, outer: Element, selector: string): Element|null {\n  for (let el: Element|null = inner; el && el !== outer; el = el.parentElement) {\n    if (el.matches(selector)) {\n      return el;\n    }\n  }\n  return null;\n}\n\nclass DomEventListener<E extends Event, T extends EventTarget> implements EventListenerObject, IDisposable {\n  constructor(protected elem: T,\n              protected eventType: string,\n              protected callback: EventCB<E, T>,\n              protected useCapture: boolean,\n              protected selector?: string) {\n    this.elem.addEventListener(this.eventType, this, this.useCapture);\n  }\n\n  public handleEvent(event: E) {\n    const cb = this.callback;\n    cb(event, this.elem);\n  }\n\n  public dispose() {\n    this.elem.removeEventListener(this.eventType, this, this.useCapture);\n  }\n}\n\nclass DomEventMatchListener<E extends Event> extends DomEventListener<E, EventTarget> {\n  public handleEvent(event: E) {\n    const elem = _findMatch(event.target as Element, this.elem as Element, this.selector!);\n    if (elem) {\n      const cb = this.callback;\n      cb(event, elem);\n    }\n  }\n}\n\n/**\n * Listen to a DOM event. The `on()` variant takes no `elem` argument, and may be used as an\n * argument to dom() function.\n * @param {DOMElement} elem: DOM Element to listen to.\n * @param {String} eventType: Event type to listen for (e.g. 'click').\n * @param {Function} callback: Callback to call as `callback(event, elem)`, where elem is `elem`.\n * @param [Boolean] options.useCapture: Add the listener in the capture phase. This should very\n *    rarely be useful (e.g. JQuery doesn't even offer it as an option).\n * @returns {Object} Listener object whose .dispose() method will remove the event listener.\n */\nexport function onElem<E extends EventName|string, T extends EventTarget>(\n  elem: T, eventType: E, callback: EventCB<EventType<E>, T>, {useCapture = false} = {}): IDisposable {\n  return new DomEventListener(elem, eventType, callback, useCapture);\n}\n\nexport function on<E extends EventName|string, T extends EventTarget>(\n  eventType: E, callback: EventCB<EventType<E>, T>, {useCapture = false} = {}): DomMethod<T> {\n  // tslint:disable-next-line:no-unused-expression\n  return (elem) => { new DomEventListener(elem, eventType, callback, useCapture); };\n}\n\n/**\n * Listen to a DOM event on descendants of the given elem matching the given selector. The\n * `onMatch()` variant takes no `elem` argument, and may be used as an argument to dom().\n * @param {DOMElement} elem: DOM Element to whose descendants to listen.\n * @param {String} selector: CSS selector string to filter elements that trigger this event.\n *    JQuery calls it \"delegated events\" (http://api.jquery.com/on/). The callback will only be\n *    called when the event occurs for an element matching the given selector. If there are\n *    multiple elements matching the selector, the callback is only called for the innermost one.\n * @param {String} eventType: Event type to listen for (e.g. 'click').\n * @param {Function} callback: Callback to call as `callback(event, elem)`, where elem is a\n *    descendent of `elem` which matches `selector`.\n * @param [Boolean] options.useCapture: Add the listener in the capture phase. This should very\n *    rarely be useful (e.g. JQuery doesn't even offer it as an option).\n * @returns {Object} Listener object whose .dispose() method will remove the event listener.\n */\nexport function onMatchElem(elem: EventTarget, selector: string, eventType: string,\n                            callback: EventCB, {useCapture = false} = {}): IDisposable {\n  return new DomEventMatchListener(elem, eventType, callback, useCapture, selector);\n}\nexport function onMatch(selector: string, eventType: string, callback: EventCB,\n                        {useCapture = false} = {}): DomElementMethod {\n  // tslint:disable-next-line:no-unused-expression\n  return (elem) => { new DomEventMatchListener(elem, eventType, callback, useCapture, selector); };\n}\n\nexport type KeyEventType = 'keypress' | 'keyup' | 'keydown';\n\nexport interface IKeyHandlers<T extends HTMLElement = HTMLElement> {\n  [key: string]: (this: void, ev: KeyboardEvent, elem: T) => void;\n}\n\n/**\n * Listen to key events (typically 'keydown' or 'keypress'), with specified per-key callbacks.\n * Key names are listed at https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n *\n * Methods onKeyPress() and onKeyDown() are intended to be used as arguments to dom().\n *\n * By default, handled events are stopped from bubbling with stopPropagation() and\n * preventDefault(). If, however, you register a key with a \"$\" suffix (i.e. \"Enter$\" instead of\n * \"Enter\"), then the event is allowed to bubble normally.\n *\n * When this handler is set on an element, we automatically ensure that tabindex attribute is set,\n * to allow this element to receive keyboard events.\n *\n * For example:\n *\n *    dom('input', ...\n *      dom.onKeyDown({\n *        Enter: (e, elem) => console.log(\"Enter pressed\"),\n *        Escape: (e, elem) => console.log(\"Escape pressed\"),\n *        Delete$: (e, elem) => console.log(\"Delete pressed, will bubble\"),\n *      })\n *    )\n */\nexport function onKeyElem<T extends HTMLElement>(\n  elem: T, evType: KeyEventType, keyHandlers: IKeyHandlers<T>,\n): IDisposable {\n  if (!(elem.tabIndex >= 0)) {                    // If tabIndex property is undefined or -1,\n    elem.setAttribute('tabindex', '-1');          // Set tabIndex attribute to make the element focusable.\n  }\n  return onElem(elem, evType, (ev, _elem) => {\n    const plainHandler = keyHandlers[ev.key];\n    const handler = plainHandler || keyHandlers[ev.key + '$'];\n    if (handler) {\n      if (plainHandler) {\n        ev.stopPropagation();\n        ev.preventDefault();\n      }\n      handler(ev, _elem);\n    }\n  });\n}\n\nexport function onKeyPress<T extends HTMLElement>(keyHandlers: IKeyHandlers<T>): DomMethod<T> {\n  return (elem) => { onKeyElem(elem, 'keypress', keyHandlers); };\n}\n\nexport function onKeyDown<T extends HTMLElement>(keyHandlers: IKeyHandlers<T>): DomMethod<T> {\n  return (elem) => { onKeyElem(elem, 'keydown', keyHandlers); };\n}\n","/**\n * emit.js implements an Emitter class which emits events to a list of listeners. Listeners are\n * simply functions to call, and \"emitting an event\" just calls those functions.\n *\n * This is similar to Backbone events, with more focus on efficiency. Both inserting and removing\n * listeners is constant time.\n *\n * To create an emitter:\n *    let emitter = new Emitter();\n *\n * To add a listener:\n *    let listener = fooEmitter.addListener(callback);\n * To remove a listener:\n *    listener.dispose();\n *\n * The only way to remove a listener is to dispose the Listener object returned by addListener().\n * You can often use autoDispose to do this automatically when subscribing in a constructor:\n *    this.autoDispose(fooEmitter.addListener(this.onFoo, this));\n *\n * To emit an event, call emit() with any number of arguments:\n *    emitter.emit(\"hello\", \"world\");\n */\n\n// Note about a possible alternative implementation.\n//\n// We could implement the same interface using an array of listeners. Certain issues apply, in\n// particular with removing listeners from inside emit(), and in ensuring that removals are\n// constant time on average. Such an implementation was attempted and timed. The result is that\n// compared to the linked-list implementation here, add/remove combination could be made nearly\n// twice faster (on average), while emit and add/remove/emit are consistently slightly slower.\n//\n// The implementation here was chosen based on those timings, and as the simpler one. For example,\n// on one setup (macbook, node4, 5-listener queue), add+remove take 0.1us, while add+remove+emit\n// take 3.82us. (In array-based implementation with same set up, add+remove is 0.06us, while\n// add+remove+emit is 4.80us.)\n\n// The private property name to hold next/prev pointers.\n\nfunction _noop() { /* noop */}\n\nexport type ListenerCB<T> = (this: T, ...args: any[]) => void;\nexport type ChangeCB = (hasListeners: boolean) => void;\n\n/**\n * This is an implementation of a doubly-linked list, with just the minimal functionality we need.\n */\nexport class LLink {\n  protected _next: LLink|null = null;\n  protected _prev: LLink|null = null;\n\n  constructor() {\n    // This immediate circular reference might be undesirable for GC, but might not matter, and\n    // makes the linked list implementation simpler and faster.\n    this._next = this;\n    this._prev = this;\n  }\n\n  public isDisposed(): boolean {\n    return !this._next;\n  }\n\n  protected _insertBefore(next: LLink, node: LLink): void {\n    const last = next._prev!;\n    last._next = node;\n    next._prev = node;\n    node._prev = last;\n    node._next = next;\n  }\n\n  protected _removeNode(node: LLink): void {\n    if (node._prev) {\n      node._prev._next = node._next;\n      node._next!._prev = node._prev;\n    }\n    node._prev = node._next = null;\n  }\n\n  protected _disposeList(): void {\n    let node: LLink = this;\n    let next = node._next;\n    while (next !== null) {\n      node._next = node._prev = null;\n      node = next;\n      next = node._next;\n    }\n  }\n}\n\nexport class Emitter extends LLink {\n  private _changeCB: ChangeCB = _noop;\n  private _changeCBContext: any = undefined;\n\n  /**\n   * Constructs an Emitter object.\n   */\n  constructor() { super(); }\n\n  /**\n   * Adds a listening callback to the list of functions to call on emit().\n   * @param {Function} callback: Function to call.\n   * @param {Object} optContext: Context for the function.\n   * @returns {Listener} Listener object. Its dispose() method removes the callback from the list.\n   */\n  public addListener<T>(callback: ListenerCB<T>, optContext?: T): Listener {\n    return new Listener(this, callback, optContext);\n  }\n\n  /**\n   * Calls all listener callbacks, passing all arguments to each of them.\n   */\n  public emit(...args: any[]): void {\n    Listener.callAll(this._next!, this, args);\n  }\n\n  /**\n   * Sets the single callback that would get called when a listener is added or removed.\n   * @param {Function} changeCB(hasListeners): Function to call after a listener is added or\n   *    removed. It's called with a boolean indicating whether this Emitter has any listeners.\n   *    Pass in `null` to unset the callback. Note that it can be called multiple times in a row\n   *    with hasListeners `true`.\n   */\n  public setChangeCB(changeCB: ChangeCB, optContext?: any): void {\n    this._changeCB = changeCB || _noop;\n    this._changeCBContext = optContext;\n  }\n\n  /**\n   * Helper used by Listener class, but not intended for public usage.\n   */\n  public _triggerChangeCB(): void {\n    this._changeCB.call(this._changeCBContext, this.hasListeners());\n  }\n\n  /**\n   * Returns whether this Emitter has any listeners.\n   */\n  public hasListeners(): boolean {\n    return this._next !== this;\n  }\n\n  /**\n   * Disposes the Emitter. It breaks references between the emitter and all the items, allowing\n   * for better garbage collection. It effectively disposes all current listeners.\n   */\n  public dispose(): void {\n    this._disposeList();\n    this._changeCB = _noop;\n    this._changeCBContext = undefined;\n  }\n}\n\n/**\n * Listener object wraps a callback added to an Emitter, allowing for O(1) removal when the\n * listener is disposed.\n */\nexport class Listener extends LLink {\n  public static callAll(begin: LLink, end: LLink, args: any[]): void {\n    while (begin !== end) {\n      const lis = begin as Listener;\n      lis.callback.call(lis.context, ...args);\n      begin = lis._next!;\n    }\n  }\n\n  constructor(private emitter: Emitter,\n              private callback: ListenerCB<any>,\n              private context?: any) {\n    super();\n    this._insertBefore(emitter, this);\n    emitter._triggerChangeCB();\n  }\n\n  public dispose(): void {\n    if (this.isDisposed()) { return; }\n    this._removeNode(this);\n    this.emitter._triggerChangeCB();\n  }\n}\n","/**\n * Grain.js observables and computeds are similar to (and mostly inspired by) those in\n * Knockout.js. In fact, they can work together.\n *\n *  import {fromKo} from 'kowrap'\n *\n *  fromKo(koObservable)\n *\n * returns a Grain.js observable that mirrors the passed-in Knockout observable (which may be a\n * computed as well). Similarly,\n *\n *  import {toKo} from 'kowrap';\n *  import * as ko from 'knockout';\n *\n *  toKo(ko, observable)\n *\n * returns a Knockout.js observable that mirrows the passed-in Grain observable or computed. Note\n * that toKo() mus tbe called with the knockout module as an argument. This is to avoid adding\n * knockout as a dependency of grainjs.\n *\n * In both cases, calling fromKo/toKo twice on the same observable will return the same wrapper,\n * and subscriptions and disposal are appropriately set up to make usage seamless. In particular,\n * the returned wrapper should not be disposed; it's tied to the lifetime of the wrapped object.\n */\n\nimport {domDisposeHooks} from './domDispose';\nimport {bundleChanges, Observable} from './observable';\n\n// Implementation note. Both wrappers are implemented in the same way.\n//\n// Regarding disposal: the wrapper is always subscribed to the underlying observable. The\n// underlying has a reference to the wrapper. So does any listener to the wrapper. The wrapper can\n// be garbage-collected once it has no listeners AND the underlying observable is disposed or\n// unreferenced.\n\nexport interface IKnockoutObservable<T> extends IKnockoutReadObservable<T> {\n  (val: T): void;\n}\n\nexport interface IKnockoutReadObservable<T> {\n  (): T;\n  peek(): T;\n  subscribe(callback: (newValue: T) => void, target?: any, event?: \"change\"): any;\n  getSubscriptionsCount(): number;\n}\n\n// Inference from Knockout observable gets very tricky because ko.Observable includes the function\n// signature `(val: T) => any` from which type `any` gets inferred. We can infer the correct type\n// with this helper.\nexport type InferKoType<KObs extends IKnockoutReadObservable<any>> =\n  KObs extends {peek(): infer T} ? T : never;\n\nconst fromKoWrappers: WeakMap<IKnockoutObservable<any>, Observable<any>> = new WeakMap();\nconst toKoWrappers: WeakMap<Observable<any>, IKnockoutObservable<any>> = new WeakMap();\n\n/**\n * Returns a Grain.js observable which mirrors a Knockout observable.\n *\n * Do not dispose this wrapper, as it is shared by all code using koObs, and its lifetime is tied\n * to the lifetime of koObs. If unused, it consumes minimal resources, and should get garbage\n * collected along with koObs.\n */\nexport function fromKo<KObs extends IKnockoutObservable<any>>(koObs: KObs): Observable<InferKoType<KObs>> {\n  return fromKoWrappers.get(koObs) || fromKoWrappers.set(koObs, new KoWrapObs(koObs)).get(koObs)!;\n}\n\n/**\n * An Observable that wraps a Knockout observable, created via fromKo(). It keeps minimal overhead\n * when unused by only subscribing to the wrapped observable while it itself has subscriptions.\n *\n * This way, when unused, the only reference is from the wrapper to the wrapped object. KoWrapObs\n * should not be disposed; its lifetime is tied to that of the wrapped object.\n */\nexport class KoWrapObs<T> extends Observable<T> {\n  private _koSub: any = null;\n\n  constructor(private _koObs: IKnockoutObservable<T>) {\n    super(_koObs.peek());\n    this.setListenerChangeCB((hasListeners) => {\n      if (!hasListeners) {\n        this._koSub.dispose();\n        this._koSub = null;\n      } else if (!this._koSub) {\n        // TODO this is a little hack, really, BaseObservable should expose a way to set the value\n        // directly by derived classes, i.e. a protected setter.\n        (this as any)._value = this._koObs.peek();\n        this._koSub = this._koObs.subscribe((val) => this.setAndTrigger(val));\n      }\n    });\n  }\n  public get(): T { return this._koObs.peek(); }\n  public set(value: T): void { bundleChanges(() => this._koObs(value)); }\n  public dispose(): void { throw new Error(\"KoWrapObs should not be disposed\"); }\n}\n\nexport interface IKnockoutModule {\n  observable<T>(value: T): IKnockoutObservable<T>;\n  cleanNode(node: Node): void;\n}\n\n/**\n * Returns a Knockout observable which mirrors a Grain.js observable.\n */\nexport function toKo<T>(knockout: IKnockoutModule, grainObs: Observable<T>): IKnockoutObservable<T> {\n  const prevKoObs = toKoWrappers.get(grainObs);\n  if (prevKoObs) {\n    return prevKoObs;\n  }\n  const newKoObs = knockout.observable(grainObs.get());\n  toKoWrappers.set(grainObs, newKoObs);\n  grainObs.addListener((val) => newKoObs(val));\n  return newKoObs;\n}\n\n// Marker for when knockout-disposal integration has already been setup.\nlet koDisposalIsSetup = false;\n\n/**\n * Set up integration between grainjs and knockout disposal. Knockout does cleanup using\n * ko.removeNode / ko.cleanNode (it also takes care of JQuery cleanup if needed). GrainJS does\n * cleanup using dom.domDispose(). By default these don't know about each other.\n *\n * If you mix the two libraries, however, disposing an element may need to trigger disposers\n * registered by either library.\n *\n * This method ensures that this happens.\n *\n * Note: grainjs disposes text nodes too, but nothing relies on it. When disposal is triggered via\n * knockout, we are forced to rely on knockout's node traversal which ignores text nodes.\n */\nexport function setupKoDisposal(ko: IKnockoutModule) {\n  // Ensure we don't do the setup more than once, or things will get called multiple times.\n  if (koDisposalIsSetup) { return; }\n  koDisposalIsSetup = true;\n\n  const koDomNodeDisposal = (ko as any).utils.domNodeDisposal;\n\n  // Knockout by default has an external-data-cleanup func set to cleanup JQuery. Whatever it is\n  // set to, we will continue calling it, and also will call grainjs domDisposeNode.\n  const origKoCleanExternalData = koDomNodeDisposal.cleanExternalData;\n\n  // The original function called by grainjs to clean nodes recursively. We'll override it.\n  const origGrainDisposeRecursive = domDisposeHooks.disposeRecursive;\n\n  // New function called by knockout to do extra cleanup. Now calls grainjs single-node cleanup.\n  // (In knockout, we can only override single-node cleanup.)\n  function newKoCleanExternalData(node: Node) {\n    origKoCleanExternalData(node);\n    domDisposeHooks.disposeNode(node);\n  }\n\n  // Function called by grainjs to clean nodes recursively. We override the recursive cleanup\n  // function to call the recursive knockout cleanup (letting knockout do the dom traversal it\n  // normally does).\n  function newGrainDisposeRecursive(node: Node) {\n    origGrainDisposeRecursive(node);\n\n    // While doing knockout cleanup, do NOT have it call grainjs cleanup too, as that would cause\n    // multiple unnecessary traversals of DOM.\n    koDomNodeDisposal.cleanExternalData = origKoCleanExternalData;\n    try {\n      ko.cleanNode(node);\n    } finally {\n      koDomNodeDisposal.cleanExternalData = newKoCleanExternalData;\n    }\n  }\n\n  // Use knockout and grainjs hooks to actually set the new cleanup functions.\n  koDomNodeDisposal.cleanExternalData = newKoCleanExternalData;\n  domDisposeHooks.disposeRecursive = newGrainDisposeRecursive;\n}\n","/**\n * ObsArray extends a plain Observable to allow for more efficient observation of array changes.\n *\n * As for any array-valued Observable, when the contents of the observed array changes, the\n * listeners get called with new and previous values which are the same array. For simple changes,\n * such as those made with .push() and .splice() methods, ObsArray allows for more efficient\n * handling of the change by calling listeners with splice info in the third argument.\n *\n * This module also provides computedArray(), which allows mapping each item of an ObsArray\n * through a function, passing through splice info for efficient handling of small changes. It\n * also allows mapping an observable or a computed whose value is an ObsArray.\n *\n * There is no need or benefit in using computedArray() if you have a computed() that returns a\n * plain array. It is specifically for the case when you want to preserve the efficiency of\n * ObsArray when you map its values.\n *\n * Both ObsArray and ComputedArray may be used with disposable elements as their owners. E.g.\n *\n *    const arr = obsArray<D>();\n *    arr.push(D.create(arr, \"x\"), D.create(arr, \"y\"));\n *    arr.pop();      // Element \"y\" gets disposed.\n *    arr.dispose();  // Element \"x\" gets disposed.\n *\n *    const values = obsArray<string>();\n *    const compArr = computedArray<D>(values, (val, i, compArr) => D.create(compArr, val));\n *    values.push(\"foo\", \"bar\");      // D(\"foo\") and D(\"bar\") get created\n *    values.pop();                   // D(\"bar\") gets disposed.\n *    compArr.dispose();              // D(\"foo\") gets disposed.\n *\n * Note that only the pattern above works: obsArray (or compArray) may only be used to take\n * ownership of those disposables that are added to it as array elements.\n */\n\nimport {IDisposable, IDisposableOwnerT, setDisposeOwner} from './dispose';\nimport {Listener} from './emit';\nimport {BaseObservable, Observable} from './observable';\nimport {subscribe, Subscription} from './subscribe';\n\n/**\n * Either an observable or a plain array of T. This is useful for functions like dom.forEach()\n * which are convenient to have available for both.\n */\nexport type MaybeObsArray<T> = BaseObservable<T[]> | T[];\n\n/**\n * Info about a modification to ObsArray contents. It is included as a third argument to change\n * listeners when available. When not available, listeners should assume that the array changed\n * completely.\n */\nexport interface IObsArraySplice<T> {\n  start: number;\n  numAdded: number;\n  deleted: T[];\n}\n\nexport type ISpliceListener<T, C>  = (this: C, val: T[], prev: T[], change?: IObsArraySplice<T>) => void;\n\n/**\n * ObsArray<T> is essentially an array-valued observable. The main difference is that it may be\n * used as an owner for disposable array elements.\n */\nexport class ObsArray<T> extends BaseObservable<T[]> {\n  private _ownedItems?: Set<T & IDisposable> = undefined;\n\n  public addListener(callback: ISpliceListener<T, void>): Listener;\n  public addListener<C>(callback: ISpliceListener<T, C>, context: C): Listener;\n  public addListener(callback: ISpliceListener<T, any>, optContext?: any): Listener {\n    return super.addListener(callback, optContext);\n  }\n\n  public autoDispose(value: T & IDisposable): T & IDisposable {\n    if (!this._ownedItems) { this._ownedItems = new Set<T & IDisposable>(); }\n    this._ownedItems.add(value);\n    return value;\n  }\n\n  public dispose(): void {\n    if (this._ownedItems) {\n      for (const item of this.get() as Array<T & IDisposable>) {\n        if (this._ownedItems.delete(item)) {\n          item.dispose();\n        }\n      }\n      this._ownedItems = undefined;\n    }\n    super.dispose();\n  }\n\n  protected _setWithSplice(value: T[], splice: IObsArraySplice<T>): void {\n    return this._setWithArg(value, splice);\n  }\n\n  protected _disposeOwned(splice?: IObsArraySplice<T>): void {\n    if (!this._ownedItems) { return; }\n    if (splice) {\n      for (const item of splice.deleted as Array<T & IDisposable>) {\n        if (this._ownedItems.delete(item)) {\n          item.dispose();\n        }\n      }\n    } else {\n      const oldOwnedItems = this._ownedItems;\n\n      // Rebuild the _ownedItems array to have only the current items that were owned from before.\n      this._ownedItems = new Set<T & IDisposable>();\n      for (const item of this.get() as Array<T & IDisposable>) {\n        if (oldOwnedItems.delete(item)) {\n          this._ownedItems.add(item);\n        }\n      }\n      // After removing current items, dispose any remaining owned items.\n      for (const item of oldOwnedItems) {\n        item.dispose();\n      }\n    }\n  }\n}\n\n/**\n * MutableObsArray<T> adds array-like mutation methods which emit events with splice info, to\n * allow more efficient processing of such changes. It is created with obsArray<T>().\n */\nexport class MutableObsArray<T> extends ObsArray<T> {\n  public push(...args: T[]): number {\n    const value = this.get();\n    const start = value.length;\n    const newLen = value.push(...args);\n    this._setWithSplice(value, {start, numAdded: args.length, deleted: []});\n    return newLen;\n  }\n\n  public pop(): T|undefined {\n    const value = this.get();\n    if (value.length === 0) { return undefined; }\n    const ret = value.pop()!;\n    this._setWithSplice(value, {start: value.length, numAdded: 0, deleted: [ret]});\n    return ret;\n  }\n\n  public unshift(...args: T[]) {\n    const value = this.get();\n    const newLen = value.unshift(...args);\n    this._setWithSplice(value, {start: 0, numAdded: args.length, deleted: []});\n    return newLen;\n  }\n\n  public shift(): T|undefined {\n    const value = this.get();\n    if (value.length === 0) { return undefined; }\n    const ret = value.shift()!;\n    this._setWithSplice(value, {start: 0, numAdded: 0, deleted: [ret]});\n    return ret;\n  }\n\n  public splice(start: number, deleteCount: number = Infinity, ...newValues: T[]) {\n    const value = this.get();\n    const len = value.length;\n    start = Math.min(len, Math.max(0, start < 0 ? len + start : start));\n    const deleted = value.splice(start, deleteCount, ...newValues);\n    this._setWithSplice(value, {start, numAdded: newValues.length, deleted});\n    return deleted;\n  }\n}\n\n/**\n * Creates a new MutableObsArray with an optional initial value, defaulting to the empty array.\n * It is essentially the same as observable<T[]>, but with array-like mutation methods.\n */\nexport function obsArray<T>(value: T[] = []): MutableObsArray<T> {\n  return new MutableObsArray<T>(value);\n}\n\n/**\n * Returns true if val is an array-valued observable.\n */\nfunction isObsArray(val: BaseObservable<any>): val is BaseObservable<any[]> {\n  return Array.isArray(val.get());\n}\n\n/**\n * See computedArray() below for documentation.\n */\nexport class ComputedArray<T, U> extends ObsArray<U> {\n  private _sub: Subscription;\n  private _source?: BaseObservable<T[]>;\n  private _listener?: Listener;\n  private _lastSplice?: IObsArraySplice<T>|false;     // false is a marker that full rebuild is needed\n\n  constructor(\n    obsArr: BaseObservable<T[]> | Observable<BaseObservable<T[]>>,\n    private _mapper: (item: T, index: number, arr: ComputedArray<T, U>) => U,\n  ) {\n    super([]);\n    this._sub = isObsArray(obsArr) ?\n      subscribe(obsArr, (use) => this._syncMap(obsArr)) :\n      subscribe(obsArr, (use, obsArrayValue) => { use(obsArrayValue); return this._syncMap(obsArrayValue); });\n  }\n\n  public dispose() {\n    this._unsync();\n    this._sub.dispose();\n    super.dispose();\n  }\n\n  private _syncMap(obsArr: BaseObservable<T[]>): void {\n    if (this._source !== obsArr) {\n      this._unsync();\n      this._listener = obsArr.addListener(this._recordChange, this);\n      this._source = obsArr;\n      this._rebuild(obsArr);\n    } else if (this._lastSplice) {\n      // If we are syncing to the same array as before and recorded a single splice, apply it now.\n      this._applySplice(obsArr, this._lastSplice);\n    } else {\n      // If the full array changed or we had multiple splices, give up and rebuild.\n      this._rebuild(obsArr);\n    }\n    this._lastSplice = undefined;\n  }\n\n  private _unsync() {\n    if (this._listener) {\n      this._listener.dispose();\n      this._listener = undefined;\n      this._source = undefined;\n    }\n  }\n\n  private _rebuild(obsArr: BaseObservable<T[]>) {\n    this.set(obsArr.get().map((item: T, i: number) => this._mapper.call(undefined, item, i, this)));\n  }\n\n  private _applySplice(obsArr: BaseObservable<T[]>, change: IObsArraySplice<T>) {\n    const sourceArray: T[] = obsArr.get();\n    const newItems: U[] = [];\n    for (let i = change.start, n = 0; n < change.numAdded; i++, n++) {\n      newItems.push(this._mapper.call(undefined, sourceArray[i], i, this));\n    }\n    const items: U[] = this.get();\n    const deleted = items.splice(change.start, change.deleted.length, ...newItems);\n    this._setWithSplice(items, {start: change.start, numAdded: newItems.length, deleted});\n  }\n\n  private _recordChange(newItems: T[], oldItems: T[], change?: IObsArraySplice<T>): void {\n    // We don't attempt to handle efficiency multiple splices (it's quite hard in general, and\n    // even harder to know that it's more efficient than rebuilding), so if _lastSplice is set, we\n    // set it to a marker to mark the array for rebuilding.\n    if (change && this._lastSplice === undefined) {\n      this._lastSplice = change;\n    } else {\n      this._lastSplice = false;     // This is a marker that a full rebuild is needed.\n    }\n  }\n}\n\n/**\n * Returns an ObsArray that maps all elements of the passed-in ObsArray through a mapper function.\n * Also accepts an observable (e.g. a computed) whose value is an ObsArray. Usage:\n *\n *    computedArray(obsArray, mapper)\n *\n * The result is entirely analogous to:\n *\n *     computed((use) => use(obsArray).map(mapper))       // for ObsArray\n *     computed((use) => use(use(obsArray)).map(mapper))  // for Observable<ObsArray>\n *\n * The benefit of computedArray() is that a small change to the source array (e.g. one item\n * added or removed), causes a small change to the mapped array, rather than a full rebuild.\n *\n * This is useful with an ObsArray or with an observable whose value is an ObsArray, and also\n * when the computed array owns its disposable items.\n *\n * Note that the mapper function is called with (item, index, array) as for a standard\n * array.map(), but that the index is only accurate at the time of the call, and will stop\n * reflecting the true index if more items are inserted into the array later.\n */\nexport function computedArray<T, U>(\n  obsArr: BaseObservable<T[]> | Observable<BaseObservable<T[]>>,\n  mapper: (item: T, index: number, arr: ComputedArray<T, U>) => U,\n): ObsArray<U> {\n  return new ComputedArray<T, U>(obsArr, mapper);\n}\n\n/**\n * Returns a new observable representing an index into this array. It can be read and written, and\n * its value is clamped to be a valid index. The index is only null if the array is empty.\n *\n * As the array changes, the index is adjusted to continue pointing to the same element. If the\n * pointed element is deleted, the index is adjusted to after the deletion point.\n *\n * The returned observable has an additional .setLive(bool) method. While set to false, the\n * observable will not be adjusted as the array changes, except to keep it valid.\n */\nexport function makeLiveIndex<T>(owner: IDisposableOwnerT<LiveIndex>|null, obsArr: ObsArray<T>,\n                                 initialIndex: number = 0): LiveIndex {\n  return setDisposeOwner(owner, new LiveIndex(obsArr, initialIndex));\n}\n\nexport class LiveIndex extends Observable<number|null> {\n  private _listener: Listener;\n  private _isLive: boolean = true;\n\n  constructor(private _obsArray: ObsArray<any>, initialIndex: number = 0) {\n    super(null);\n    this.set(initialIndex);\n    this._listener = _obsArray.addListener(this._onArrayChange, this);\n  }\n\n  public set(index: number|null) {\n    // Clamp to [0, len) range of the observable array.\n    const len = this._obsArray.get().length;\n    super.set(len === 0 ? null : Math.max(0, Math.min(len - 1, index || 0)));\n  }\n\n  // Note that this feature comes from a rather obscure need, and it would be better if something\n  // similar were possible without making it an explicit feature.\n  public setLive(value: boolean): void {\n    this._isLive = value;\n  }\n\n  public dispose() {\n    this._listener.dispose();\n    super.dispose();\n  }\n\n  private _onArrayChange<T>(newItems: T[], oldItems: T[], change?: IObsArraySplice<T>) {\n    const idx = this.get();\n    this.set(\n      idx === null || !change ? 0 :\n      // Adjust the index if it was beyond the deleted region.\n      this._isLive && idx >= change.start + change.deleted.length ? idx + change.numAdded - change.deleted.length :\n      // Adjust the index if it was inside the deleted region (and not replaced).\n      this._isLive && idx >= change.start + change.numAdded ? change.start + change.numAdded :\n      idx);\n  }\n}\n","/**\n * observable.js implements an observable value, which lets other code subscribe to changes.\n *\n * E.g.\n *  let o = observable(17);\n *  o.get();          // 17\n *  o.addListener(foo);\n *  o.set(\"asdf\");    // foo(\"asdf\", 17) gets called.\n *  o.get();          // \"asdf\"\n *\n * To subscribe to changes, use obs.addListener(callback, context). The callback will get called\n * with (newValue, oldValue) as arguments.\n *\n * When you use observables within the body of a computed(), you can automatically create\n * subscriptions to them with the use(obs) function. E.g.\n *    let obs3 = computed(use => use(obs1) + use(obs2));\n * creates a computed observable `obs3` which is subscribed to changes to `obs1` and `obs2`.\n *\n * Note that unlike with knockout, use(obs) method requires an explicit `use` function, which is\n * always passed to a computed's read() callback for this purpose. This makes it explicit when a\n * dependency is created, and which observables the dependency connects.\n */\n\nimport {compute, DepItem} from './_computed_queue';\nimport {IDisposable, IDisposableOwnerT, setDisposeOwner} from './dispose';\nimport {Emitter, Listener} from './emit';\n\nexport {bundleChanges} from './_computed_queue';\n\nexport class BaseObservable<T> {\n  private _onChange: Emitter;\n  private _value: T;\n\n  /**\n   * Internal constructor for an Observable. You should use observable() function instead.\n   */\n  constructor(value: T) {\n    this._onChange = new Emitter();\n    this._value = value;\n  }\n\n  /**\n   * Returns the value of the observable. It is fast and does not create a subscription.\n   * (It is similar to knockout's peek()).\n   * @returns {Object} The current value of the observable.\n   */\n  public get(): T { return this._value; }\n\n  /**\n   * Sets the value of the observable. If the value differs from the previously set one, then\n   * listeners to this observable will get called with (newValue, oldValue) as arguments.\n   * @param {Object} value: The new value to set.\n   */\n  public set(value: T): void {\n    if (value !== this._value) {\n      this.setAndTrigger(value);\n    }\n  }\n\n  /**\n   * Sets the value of the observable AND calls listeners even if the value is unchanged.\n   */\n  public setAndTrigger(value: T) {\n    const prev = this._value;\n    this._value = value;\n    this._onChange.emit(value, prev);\n    this._disposeOwned();\n    compute();\n  }\n\n  /**\n   * Adds a callback to listen to changes in the observable.\n   * @param {Function} callback: Function, called on changes with (newValue, oldValue) arguments.\n   * @param {Object} optContext: Context for the function.\n   * @returns {Listener} Listener object. Its dispose() method removes the callback.\n   */\n  public addListener(callback: (val: T, prev: T) => void, optContext?: object): Listener {\n    return this._onChange.addListener(callback, optContext);\n  }\n\n  /**\n   * Returns whether this observable has any listeners.\n   */\n  public hasListeners(): boolean {\n    return this._onChange.hasListeners();\n  }\n\n  /**\n   * Sets a single callback to be called when a listener is added or removed. It overwrites any\n   * previously-set such callback.\n   * @param {Function} changeCB(hasListeners): Function to call after a listener is added or\n   *    removed. It's called with a boolean indicating whether this observable has any listeners.\n   *    Pass in `null` to unset the callback. Note that it can be called multiple times in a row\n   *    with hasListeners `true`.\n   */\n  public setListenerChangeCB(changeCB: (hasListeners: boolean) => void, optContext?: any): void {\n    this._onChange.setChangeCB(changeCB, optContext);\n  }\n\n  /**\n   * Used by subscriptions to keep track of dependencies. An observable that has dependnecies,\n   * such as a computed observable, would override this method.\n   */\n  public _getDepItem(): DepItem|null {\n    return null;\n  }\n\n  /**\n   * Disposes the observable.\n   */\n  public dispose(): void {\n    this._disposeOwned();\n    this._onChange.dispose();\n    (this._value as any) = undefined;\n  }\n\n  /**\n   * Returns whether this observable is disposed.\n   */\n  public isDisposed(): boolean {\n    return this._onChange.isDisposed();\n  }\n\n  protected _disposeOwned(arg?: any) { /* noop */ }\n\n  /**\n   * Allow derived classes to emit change events with an additional third argument describing the\n   * change. It always emits the event without checking for value equality.\n   */\n  protected _setWithArg(value: T, arg: any) {\n    const prev = this._value;\n    this._value = value;\n    this._onChange.emit(value, prev, arg);\n    this._disposeOwned(arg);\n    compute();\n  }\n}\n\nexport class Observable<T> extends BaseObservable<T> implements IDisposableOwnerT<T & IDisposable> {\n  // See module-level holder() function below for documentation.\n  public static holder<T>(value: T & IDisposable): Observable<T> {\n    const obs = new Observable<T>(value);\n    obs._owned = value;\n    return obs;\n  }\n\n  /**\n   * Creates a new Observable with the given initial value, and owned by owner.\n   */\n  public static create<T>(owner: IDisposableOwnerT<Observable<T>>|null, value: T): Observable<T> {\n    return setDisposeOwner(owner, new Observable<T>(value));\n  }\n\n  private _owned?: T & IDisposable = undefined;\n\n  /**\n   * The use an observable for a disposable object, use it a DisposableOwner:\n   *\n   *    D.create(obs, ...args)                      // Preferred\n   *    obs.autoDispose(D.create(null, ...args))    // Equivalent\n   *\n   * Either of these usages will set the observable to the newly created value. The observable\n   * will dispose the owned value when it's set to another value, or when it itself is disposed.\n   */\n  public autoDispose(value: T & IDisposable): T & IDisposable {\n    this.setAndTrigger(value);\n    this._owned = value;\n    return value;\n  }\n\n  protected _disposeOwned() {\n    if (this._owned) {\n      this._owned.dispose();\n      this._owned = undefined;\n    }\n  }\n}\n\n/**\n * Creates a new Observable with the initial value of optValue if given or undefined if omitted.\n * @param {Object} optValue: The initial value to set.\n * @returns {Observable} The newly created observable.\n */\nexport function observable<T>(value: T): Observable<T> {\n  return new Observable<T>(value);\n}\n\n/**\n * Creates a new Observable with an initial disposable value owned by this observable, e.g.\n *\n *    const obs = obsHolder<D>(D.create(null, ...args));\n *\n * This is needed because using simply observable<D>(value) would not cause the observable to take\n * ownership of value (i.e. to dispose it later). This function is a less hacky equivalent to:\n *\n *    const obs = observable<D>(null as any);\n *    D.create(obs, ...args);\n *\n * To allow nulls, use observable<D|null>(null); then the obsHolder() constructor is not needed.\n */\nexport function obsHolder<T>(value: T & IDisposable): Observable<T> {\n  return Observable.holder<T>(value);\n}\n","/**\n * pureComputed.js implements a variant of computed() suitable for use with a pure read function\n * (free of side-effects). A pureComputed is only subscribed to its dependencies when something is\n * subscribed to it. At other times, it is not subscribed to anything, and calls to `get()` will\n * recompute its value each time by calling its read() function.\n *\n * Its syntax and usage are otherwise exactly as for a computed.\n *\n * In addition to being cheaper when unused, a pureComputed() also avoids leaking memory when\n * unused (since it's not registered with dependencies), so it is not necessary to dispose it.\n */\n\nimport {DepItem} from './_computed_queue';\nimport {IKnockoutReadObservable} from './kowrap';\nimport {BaseObservable, Observable} from './observable';\nimport {ISubscribable, ISubscribableObs, Subscription, UseCB} from './subscribe';\n\nfunction _noWrite(): never {\n  throw new Error(\"Can't write to non-writable pureComputed\");\n}\n\nfunction _useFunc<T>(obs: BaseObservable<T>|IKnockoutReadObservable<T>): T {\n  return ('get' in obs) ? obs.get() : obs.peek();\n}\n\n// Constant empty array, which we use to avoid allocating new read-only empty arrays.\nconst emptyArray: ReadonlyArray<any> = [];\n\nexport class PureComputed<T> extends Observable<T> {\n  private _callback: (use: UseCB, ...args: any[]) => T;\n  private _write: (value: T) => void;\n  private _sub: Subscription|null;\n  private readonly _dependencies: ReadonlyArray<ISubscribableObs>;\n  private _inCall: boolean;\n\n  /**\n   * Internal constructor for a PureComputed. You should use pureComputed() function instead.\n   */\n  constructor(callback: (use: UseCB, ...args: any[]) => T, dependencies: ReadonlyArray<ISubscribable>) {\n    // At initialization we force an undefined value even though it's not of type T: it's not\n    // actually used as get() is overridden.\n    super(undefined as any);\n    this._callback = callback;\n    this._write = _noWrite;\n    this._dependencies = dependencies.length > 0 ? dependencies : emptyArray;\n    this._sub = null;\n    this._inCall = false;\n    this.setListenerChangeCB(this._onListenerChange, this);\n  }\n\n  public _getDepItem(): DepItem {\n    this._activate();\n    return this._sub!._getDepItem();\n  }\n\n  public get(): T {\n    if (!this._sub && !this._inCall) {\n      // _inCall member prevents infinite recursion.\n      this._inCall = true;\n      try {\n        const readArgs: [UseCB, ...any[]] = [_useFunc];\n        // Note that this attempts to optimize for speed.\n        for (let i = 0, len = this._dependencies.length; i < len; i++) {\n          readArgs[i + 1] = this._dependencies[i].get();\n        }\n        super.set(this._callback.apply(undefined, readArgs));\n      } finally {\n        this._inCall = false;\n      }\n    }\n    return super.get();\n  }\n\n  /**\n   * \"Sets\" the value of the pure computed by calling the write() callback if one was provided in\n   * the constructor. Throws an error if there was no such callback (not a \"writable\" computed).\n   * @param {Object} value: The value to pass to the write() callback.\n   */\n  public set(value: T): void { this._write(value); }\n\n  /**\n   * Set callback to call when this.set(value) is called, to make it a writable computed. If not\n   * set, attempting to write to this computed will throw an exception.\n   */\n  public onWrite(writeFunc: (value: T) => void): PureComputed<T> {\n    this._write = writeFunc;\n    return this;\n  }\n\n  /**\n   * Disposes the pureComputed, unsubscribing it from all observables it depends on.\n   */\n  public dispose() {\n    if (this._sub) {\n      this._sub.dispose();\n    }\n    // Truthy value for _sub prevents some errors after disposal, by avoiding activation or\n    // _directRead calls.\n    this._sub = true as any;\n    super.dispose();\n  }\n\n  private _activate(): void {\n    if (!this._sub) {\n      this._sub = new Subscription(this._read.bind(this), this._dependencies);\n    }\n  }\n\n  private _onListenerChange(hasListeners: boolean): void {\n    if (hasListeners) {\n      this._activate();\n    } else if (this._sub) {\n      this._sub.dispose();\n      this._sub = null;\n    }\n  }\n\n  private _read(use: any, ...args: any[]): void {\n    super.set(this._callback(use, ...args));\n  }\n}\n\n/**\n * This is the type-checking interface for pureComputed(), which allows TypeScript to do helpful\n * type-checking when using it. We can only support a fixed number of argumnets (explicit\n * dependencies), but 5 should almost always be enough.\n */\nexport function pureComputed<T>(cb: (use: UseCB) => T): PureComputed<T>;\n\nexport function pureComputed<A, T>(\n    a: Observable<A>,\n    cb: (use: UseCB, a: A) => T): PureComputed<T>;\n\nexport function pureComputed<A, B, T>(\n    a: Observable<A>, b: Observable<B>,\n    cb: (use: UseCB, a: A, b: B) => T): PureComputed<T>;\n\nexport function pureComputed<A, B, C, T>(\n    a: Observable<A>, b: Observable<B>, c: Observable<C>,\n    cb: (use: UseCB, a: A, b: B, c: C) => T): PureComputed<T>;\n\nexport function pureComputed<A, B, C, D, T>(\n    a: Observable<A>, b: Observable<B>, c: Observable<C>, d: Observable<D>,\n    cb: (use: UseCB, a: A, b: B, c: C, d: D) => T): PureComputed<T>;\n\nexport function pureComputed<A, B, C, D, E, T>(\n    a: Observable<A>, b: Observable<B>, c: Observable<C>, d: Observable<D>, e: Observable<E>,\n    cb: (use: UseCB, a: A, b: B, c: C, d: D, e: E) => T): PureComputed<T>;\n\n/**\n * Creates and returns a new PureComputed. The interface is identical to that of a Computed.\n */\nexport function pureComputed(...args: any[]): PureComputed<any> {\n  const readCb = args.pop();\n  // The cast helps ensure that Observable is compatible with ISubscribable abstraction that we use.\n  return new PureComputed<any>(readCb, args);\n}\n","/**\n * In-code styling for DOM components, inspired by Reacts Styled Components.\n *\n * Usage:\n *    const title = styled('h1', `\n *      font-size: 1.5em;\n *      text-align: center;\n *      color: palevioletred;\n *    `);\n *\n *    const wrapper = styled('section', `\n *      padding: 4em;\n *      background: papayawhip;\n *    `);\n *\n *    wrapper(title('Hello world'))\n *\n * This generates class names for title and wrapper, adds the styles to the document on first use,\n * and the result is equivalent to:\n *\n *    dom(`section.${wrapper.className}`, dom(`h1.${title.className}`, 'Hello world'));\n *\n * Calls to styled() should happen at the top level, at import time, in order to register all\n * styles upfront. Actual work happens the first time a style is needed to create an element.\n * Calling styled() elsewhere than at top level is wasteful and bad for performance.\n *\n * You may create a style that modifies an existing styled() or other component, e.g.\n *\n *    const title2 = styled(title, `font-size: 1rem; color: red;`);\n *\n * Calling title2('Foo') becomes equivalent to dom(`h1.${title.className}.${title2.className}`).\n *\n * Styles may incorporate other related styles by nesting them under the main one as follows:\n *\n *     const myButton = styled('button', `\n *       border-radius: 0.5rem;\n *       border: 1px solid grey;\n *       font-size: 1rem;\n *\n *       &:active {\n *         background: lightblue;\n *       }\n *       &-small {\n *         font-size: 0.6rem;\n *       }\n *     `);\n *\n * In nested styles, ampersand (&) gets replaced with the generated .className of the main element.\n *\n * The resulting styled component provides a .cls() helper to simplify using prefixed classes. It\n * behaves as dom.cls(), but prefixes the class names with the generated className of the main\n * element. E.g. for the example above,\n *\n *      myButton(myButton.cls('-small'), 'Test')\n *\n * creates a button with both the myButton style above, and the style specified under \"&-small\".\n *\n * Animations with @keyframes may be created with a unique name by using the keyframes() helper:\n *\n *    const rotate360 = keyframes(`\n *      from { transform: rotate(0deg); }\n *      to { transform: rotate(360deg); }\n *    `);\n *\n *    const Rotate = styled('div', `\n *      display: inline-block;\n *      animation: ${rotate360} 2s linear infinite;\n *    `);\n */\n\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nimport {G} from './browserGlobals';\nimport {dom, IDomArgs, TagElem, TagName} from './domImpl';\nimport {cls, clsPrefix} from './domMethods';\n\n// The value returned by styled() matches the input (first argument), and also implements IClsName\n// interface.\nexport interface IClsName {\n  className: string;      // Name of the generated class.\n  cls: typeof cls;        // Helper like dom.cls(), but which prefixes classes by className.\n}\n\nexport type DomCreateFunc<R, Args extends IDomArgs<R> = IDomArgs<R>> = (...args: Args) => R;\n\n// See module documentation for details.\nexport function styled<Tag extends TagName>(tag: Tag, styles: string): DomCreateFunc<TagElem<Tag>> & IClsName;\nexport function styled<Args extends any[], R extends Element>(\n  creator: (...args: Args) => R, styles: string): typeof creator & IClsName;\nexport function styled(creator: any, styles: string): IClsName {\n  // Note that we intentionally minimize the work done when styled() is called; it's better to do\n  // any needed work on first use. That's when we will actually build the css rules.\n  const style = new StylePiece(styles);\n\n  // Creator function reflects the input, with only the addition of style.use() at the end. Note\n  // that it needs to be at the end because creator() might take special initial arguments.\n  const newCreator = (typeof creator === 'string') ?\n    (...args: any[]) => style.addToElem(dom(creator, ...args)) :\n    (...args: any[]) => style.addToElem(creator(...args));\n  return Object.assign(newCreator, {\n    className: style.className,\n    cls: clsPrefix.bind(null, style.className),\n  });\n}\n\n// Keyframes produces simply a string with the generated name. Note that these does not support\n// nesting or ampersand (&) handling, since these would be difficult and are entirely unneeded.\nexport function keyframes(styles: string): string {\n  return (new KeyframePiece(styles)).className;\n}\n\nfunction createCssRules(className: string, styles: string) {\n  // The first time we encounter a nested section, we know which are the \"main\" rules, and can\n  // wrap them appropriately.\n  const nestedStart = styles.search(/[^;]*\\{/);\n  const mainRules = nestedStart < 0 ? styles : styles.slice(0, nestedStart);\n  const nestedRules = nestedStart < 0 ? \"\" : styles.slice(nestedStart);\n\n  // At the end, replace all occurrences of & with \".className\".\n  return `& {${mainRules}\\n}\\n${nestedRules}`.replace(/&/g, className);\n}\n\n// Used by getNextStyleNum when running without a global window object (e.g. in tests).\nconst _global = {};\n\n// Keep the counter for next class attached to the global window object rather than be a library\n// global. This way if by some chance multiple instance of grainjs are loaded into the page, it\n// still works without overwriting class names (which would be extremely confusing).\nfunction getNextStyleNum() {\n  const g: any = G.window || _global;\n  return g._grainNextStyleNum = (g._grainNextStyleNum || 0) + 1;\n}\n\nclass StylePiece {\n  // Set of all StylePieces created but not yet mounted.\n  private static _unmounted = new Set<StylePiece>();\n\n  // Generate a new css class name. The suffix ensures that names like \"&2\" can't cause a conflict.\n  private static _nextClassName() { return `_grain${getNextStyleNum()}_`; }\n\n  // Mount all unmounted StylePieces, and clear the _unmounted map.\n  private static _mountAll(): void {\n    const sheet: string = Array.from(this._unmounted, (p) => p._createRules()).join(\"\\n\\n\");\n\n    G.document.head!.appendChild(dom('style', sheet));\n    for (const piece of this._unmounted) {\n      piece._mounted = true;\n    }\n    this._unmounted.clear();\n  }\n\n  public readonly className: string;\n  private _mounted: boolean = false;\n\n  constructor(protected _styles: string) {\n    this.className = StylePiece._nextClassName();\n    StylePiece._unmounted.add(this);\n  }\n\n  public addToElem<T extends Element>(elem: T): T {\n    if (!this._mounted) { StylePiece._mountAll(); }\n    elem.classList.add(this.className);\n    return elem;\n  }\n\n  protected _createRules(): string {\n    return createCssRules('.' + this.className, this._styles);\n  }\n}\n\nclass KeyframePiece extends StylePiece {\n  protected _createRules(): string {\n    return `@keyframes ${this.className} {${this._styles}}`;\n  }\n}\n","/**\n * subscribe.js implements subscriptions to several observables at once.\n *\n * E.g. if we have some existing observables (which may be instances of `computed`),\n * we can subscribe to them explicitly:\n *    let obs1 = observable(5), obs2 = observable(12);\n *    subscribe(obs1, obs2, (use, v1, v2) => console.log(v1, v2));\n *\n * or implicitly by using `use(obs)` function, which allows dynamic subscriptions:\n *    subscribe(use => console.log(use(obs1), use(obs2)));\n *\n * In either case, if obs1 or obs2 is changed, the callbacks will get called automatically.\n *\n * Creating a subscription allows any number of dependencies to be specified explicitly, and their\n * values will be passed to the callback(). These may be combined with automatic dependencies\n * detected using use(). Note that constructor dependencies have less overhead.\n *\n *    subscribe(...deps, ((use, ...depValues) => READ_CALLBACK));\n */\n\nimport {DepItem} from './_computed_queue';\nimport {IDisposableOwner} from './dispose';\nimport {Listener} from './emit';\nimport {fromKo, IKnockoutReadObservable} from './kowrap';\nimport {BaseObservable as Obs} from './observable';\n\nexport interface ISubscribableObs {\n  _getDepItem(): DepItem|null;\n  addListener(callback: (val: any, prev: any) => void, optContext?: object): Listener;\n  get(): any;\n}\n\nexport type ISubscribable = ISubscribableObs | IKnockoutReadObservable<any>;\n\n// Type inference from the simpler Obs<T>|IKnockoutReadObservable<T> does not always produce\n// correct T for ko.Observable. The formula below is a workaround. See also InferKoType in kowrap.\nexport type InferUseType<TObs extends Obs<any>|IKnockoutReadObservable<any>> =\n  TObs extends Obs<infer T> ? T :\n  TObs extends {peek(): infer U} ? U : never;\n\n// The generic type for the use() function that callbacks get.\nexport type UseCB = <TObs extends Obs<any>|IKnockoutReadObservable<any>>(obs: TObs) => InferUseType<TObs>;\n\nexport interface UseCBOwner extends UseCB {    // tslint:disable-line:interface-name\n  owner: IDisposableOwner;\n}\n\ninterface IListenerWithInUse extends Listener {\n  _inUse: boolean;\n}\n\n// Constant empty array, which we use to avoid allocating new read-only empty arrays.\nconst emptyArray: ReadonlyArray<any> = [];\n\nexport class Subscription {\n  private readonly _depItem: DepItem;\n  private readonly _dependencies: ReadonlyArray<ISubscribableObs>;\n  private readonly _depListeners: ReadonlyArray<Listener>;\n  private _dynDeps: Map<ISubscribableObs, IListenerWithInUse>;\n  private _callback: (use: UseCB, ...args: any[]) => void;\n  private _useFunc: UseCB;\n\n  /**\n   * Internal constructor for a Subscription. You should use subscribe() function instead.\n   * The last owner argument is used by computed() to make itself available as the .owner property\n   * of the 'use' function that gets passed to the callback.\n   */\n  constructor(callback: (use: UseCB, ...args: any[]) => void, dependencies: ReadonlyArray<ISubscribable>, owner?: any) {\n    this._depItem = new DepItem(this._evaluate, this);\n    this._dependencies = dependencies.length > 0 ? dependencies : emptyArray;\n    this._depListeners = dependencies.length > 0 ? dependencies.map((obs) => this._subscribeTo(obs)) : emptyArray;\n    this._dynDeps = new Map();   // Maps dependent observable to its Listener object.\n    this._callback = callback;\n    this._useFunc = this._useDependency.bind(this);\n    if (owner) {\n      (this._useFunc as UseCBOwner).owner = owner;\n    }\n\n    this._evaluate();\n  }\n\n  /**\n   * Disposes the computed, unsubscribing it from all observables it depends on.\n   */\n  public dispose() {\n    this._callback = null as any;\n    for (const lis of this._depListeners) { lis.dispose(); }\n    for (const lis of this._dynDeps.values()) { lis.dispose(); }\n  }\n\n  /**\n   * For use by computed(): returns this subscription's hook into the _computed_queue.\n   */\n  public _getDepItem(): DepItem { return this._depItem; }\n\n  /**\n   * @private\n   * Gets called when the callback calls `use(obs)` for an observable. It creates a\n   * subscription to `obs` if one doesn't yet exist.\n   * @param {Observable} obs: The observable being used as a dependency.\n   */\n  private _useDependency(_obs: ISubscribable) {\n    const obs = ('_getDepItem' in _obs) ? _obs : fromKo(_obs);\n    let listener = this._dynDeps.get(obs);\n    if (!listener) {\n      listener = this._subscribeTo(obs) as IListenerWithInUse;\n      this._dynDeps.set(obs, listener);\n    }\n    listener._inUse = true;\n    this._depItem.useDep(obs._getDepItem());\n    return obs.get();\n  }\n\n  /**\n   * @private\n   * Calls the callback() with appropriate args, and updates subscriptions when it is done.\n   * I.e. adds dynamic subscriptions created via `use(obs)`, and disposes those no longer used.\n   */\n  private _evaluate() {\n    if (this._callback === null) { return; }      // Means this Subscription has been disposed.\n    try {\n      // Note that this is faster than using .map().\n      const readArgs: [UseCB, ...any[]] = [this._useFunc];\n      for (let i = 0, len = this._dependencies.length; i < len; i++) {\n        readArgs[i + 1] = this._dependencies[i].get();\n        this._depItem.useDep(this._dependencies[i]._getDepItem());\n      }\n      return this._callback.apply(undefined, readArgs);\n\n    } finally {\n      this._dynDeps.forEach((listener, obs) => {\n        if (listener._inUse) {\n          listener._inUse = false;\n        } else {\n          this._dynDeps.delete(obs);\n          listener.dispose();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   * Subscribes this computed to another observable that it depends on.\n   * @param {Observable} obs: The observable to subscribe to.\n   * @returns {Listener} Listener object.\n   */\n  private _subscribeTo(_obs: ISubscribable) {\n    const obs = ('_getDepItem' in _obs) ? _obs : fromKo(_obs);\n    return obs.addListener(this._enqueue, this);\n  }\n\n  /**\n   * @private\n   * Adds this item to the recompute queue.\n   */\n  private _enqueue() {\n    this._depItem.enqueue();\n  }\n}\n\n/**\n * This is the type-checking interface for subscribe(), which allows TypeScript to do helpful\n * type-checking when using it. We can only support a fixed number of argumnets (explicit\n * dependencies), but 5 should almost always be enough.\n */\nexport function subscribe(cb: (use: UseCB) => void): Subscription;\n\nexport function subscribe<A>(\n    a: Obs<A>,\n    cb: (use: UseCB, a: A) => void): Subscription;\n\nexport function subscribe<A, B>(\n    a: Obs<A>, b: Obs<B>,\n    cb: (use: UseCB, a: A, b: B) => void): Subscription;\n\nexport function subscribe<A, B, C>(\n    a: Obs<A>, b: Obs<B>, c: Obs<C>,\n    cb: (use: UseCB, a: A, b: B, c: C) => void): Subscription;\n\nexport function subscribe<A, B, C, D>(\n    a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>,\n    cb: (use: UseCB, a: A, b: B, c: C, d: D) => void): Subscription;\n\nexport function subscribe<A, B, C, D, E>(\n    a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>, e: Obs<E>,\n    cb: (use: UseCB, a: A, b: B, c: C, d: D, e: E) => void): Subscription;\n\n/**\n * Creates a new Subscription.\n * @param {Observable} ...observables: The initial params, of which there may be zero or more, are\n *    observables on which this computed depends. When any of them change, the callback()\n *    will be called with the values of these observables as arguments.\n * @param {Function} callback: will be called with arguments (use, ...values), i.e. the\n *    `use` function and values for all of the ...observables that precede this argument.\n *    This callback is called immediately, and whenever any dependency changes.\n * @returns {Subscription} The new subscription which may be disposed to unsubscribe.\n */\nexport function subscribe(...args: any[]): Subscription {\n  const cb = args.pop();\n  // The cast helps ensure that Observable is compatible with ISubscribable abstraction that we use.\n  return new Subscription(cb, args as Array<Obs<any>>);\n}\n","\n/**\n * Returns f such that f() calls func(...boundArgs), i.e. optimizes `() => func(...boundArgs)`.\n * It is faster on node6 by 57-92%.\n */\nexport function bindB<R>(func: (...args: any[]) => R, b: any[]): () => R {\n  switch (b.length) {\n    case 0: return () => func();\n    case 1: return () => func(b[0]);\n    case 2: return () => func(b[0], b[1]);\n    case 3: return () => func(b[0], b[1], b[2]);\n    case 4: return () => func(b[0], b[1], b[2], b[3]);\n    case 5: return () => func(b[0], b[1], b[2], b[3], b[4]);\n    case 6: return () => func(b[0], b[1], b[2], b[3], b[4], b[5]);\n    case 7: return () => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6]);\n    case 8: return () => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\n    default: return () => func.apply(undefined, b);\n  }\n}\n\n/**\n * Returns f such that f(unboundArg) calls func(unboundArg, ...boundArgs).\n * I.e. optimizes `(arg) => func(arg, ...boundArgs)`.\n * It is faster on node6 by 0-92%.\n */\nexport function bindUB<U, R>(func: (arg: U, ...args: any[]) => R, b: any[]): (arg: U) => R {\n  switch (b.length) {\n    case 0: return (arg) => func(arg);\n    case 1: return (arg) => func(arg, b[0]);\n    case 2: return (arg) => func(arg, b[0], b[1]);\n    case 3: return (arg) => func(arg, b[0], b[1], b[2]);\n    case 4: return (arg) => func(arg, b[0], b[1], b[2], b[3]);\n    case 5: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4]);\n    case 6: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4], b[5]);\n    case 7: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4], b[5], b[6]);\n    case 8: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\n    default: return (arg) => func(arg, ...b);\n  }\n}\n\n/**\n * Returns f such that f(unboundArg) calls func(...boundArgs, unboundArg).\n * I.e. optimizes `(arg) => func(...boundArgs, arg)`.\n * It is faster on node6 by 0-92%.\n */\nexport function bindBU<R>(func: (...args: any[]) => R, b: any[]): (arg: any) => R {\n  switch (b.length) {\n    case 0: return (arg) => func(arg);\n    case 1: return (arg) => func(b[0], arg);\n    case 2: return (arg) => func(b[0], b[1], arg);\n    case 3: return (arg) => func(b[0], b[1], b[2], arg);\n    case 4: return (arg) => func(b[0], b[1], b[2], b[3], arg);\n    case 5: return (arg) => func(b[0], b[1], b[2], b[3], b[4], arg);\n    case 6: return (arg) => func(b[0], b[1], b[2], b[3], b[4], b[5], arg);\n    case 7: return (arg) => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6], arg);\n    case 8: return (arg) => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], arg);\n    default: return (arg) => func(...b, arg);\n  }\n}\n","/**\n * General INPUT widget.\n */\nimport {bundleChanges, dom, IDomArgs, Observable, subscribe} from '../../index';\n\nexport interface IInputOptions {\n  onInput?: boolean;      // If set, update the observable on every keystroke.\n\n  // If given, this observable will be set whenever email is set, to elem.validity.valid boolean;\n  // see https://developer.mozilla.org/en-US/docs/Web/API/ValidityState.\n  isValid?: Observable<boolean>;\n}\n\n/**\n * Creates a input element tied to the given observable. The required options argument allows\n * controlling the behavior, see IInputOptions for details.\n *\n * This is intended for string input elements, with \"type\" such as text, email, url, password,\n * number, tel.\n *\n * Note that every change to the observable will affect the input element, but not every change to\n * the input element will affect the observable. Specifically, unless {onInput: true} is set, the\n * visible content may differ from the observable until the element loses focus or Enter is hit.\n *\n * Example usage:\n *    input(obs, {}, {type: 'text', placeholder: 'Your name...'});\n *    input(obs, {isValid: isValidObs}, {type: 'email', placeholder: 'Your email...'});\n *    input(obs, {onInput: true}, {type: 'text'});\n */\nexport function input(\n  obs: Observable<string>, options: IInputOptions, ...args: IDomArgs<HTMLInputElement>\n): HTMLInputElement {\n\n  const isValid = options.isValid;\n\n  function setValue(elem: HTMLInputElement) {\n    bundleChanges(() => {\n      obs.set(elem.value);\n      if (isValid) { isValid.set(elem.validity.valid); }\n    });\n  }\n\n  return dom('input', ...args,\n    dom.prop('value', obs),\n    (isValid ?\n      (elem) => dom.autoDisposeElem(elem,\n        subscribe(obs, (use) => isValid.set(elem.checkValidity()))) :\n      null),\n    options.onInput ? dom.on('input', (e, elem) => setValue(elem)) : null,\n    dom.on('change', (e, elem) => setValue(elem)),\n    dom.onKeyPress({Enter: (e, elem) => setValue(elem)}),\n  );\n}\n","/**\n * Select dropdown widget.\n */\nimport {dom, MaybeObsArray, Observable, subscribe} from '../../index';\n\nexport interface IOptionFull<T> {\n  value: T;\n  label: string;\n  disabled?: boolean;\n}\n\n// For string options, we can use a string for label and value, without wrapping into an object.\nexport type IOption<T> = (T & string) | IOptionFull<T>;\n\nfunction unwrapMaybeObsArray<T>(array: MaybeObsArray<T>): T[] {\n  return Array.isArray(array) ? array : array.get();\n}\n\nfunction getOptionValue<T>(option: IOption<T>): T {\n  return (typeof option === \"string\") ?\n    option : (option as IOptionFull<T>).value;\n}\n\n/**\n * Creates a select dropdown widget. The observable `obs` reflects the value of the selected\n * option, and `optionArray` is an array (regular or observable) of option values and labels.\n * These may be either strings, or {label, value, disabled} objects.\n *\n * The type of value may be any type at all; it is opaque to this widget.\n *\n * If obs is set to an invalid or disabled value, then defLabel option is used to determine the\n * label that the select box will show, blank by default.\n *\n * Usage:\n *    const fruit = observable(\"apple\");\n *    select(fruit, [\"apple\", \"banana\", \"mango\"]);\n *\n *    const employee = observable(17);\n *    const employees = obsArray<IOption<number>>([\n *      {value: 12, label: \"Bob\", disabled: true},\n *      {value: 17, label: \"Alice\"},\n *      {value: 21, label: \"Eve\"},\n *    ]);\n *    select(employee, employees, {defLabel: \"Select employee:\"});\n */\nexport function select<T>(obs: Observable<T>, optionArray: MaybeObsArray<IOption<T>>,\n                          options: {defLabel?: string} = {}) {\n  const {defLabel = \"\"} = options;\n  return dom('select',\n    // Include a hidden option to represent a default value. This one gets shown when none of the\n    // options are selected. This is more consistent when showing the first valid option.\n    dom('option', dom.hide(true), defLabel),\n\n    // Create all the option elements.\n    dom.forEach(optionArray, (option) => {\n      const obj: IOptionFull<T> = (typeof option === \"string\") ?\n        {value: option, label: option} : (option as IOptionFull<T>);\n      // Note we only set 'selected' when an <option> is created; we are not subscribing to obs.\n      // This is to reduce the amount of subscriptions, esp. when number of options is large.\n      return dom('option', {\n        disabled: obj.disabled,\n        selected: obj.value === obs.get(),\n      }, obj.label);\n    }),\n\n    // When obs changes, update select's value; we do it after <options> have been created.\n    // Note that autoDisposeElem ensures the subscription is disposed with the 'select' element.\n    (elem) => dom.autoDisposeElem(elem, subscribe(obs, (use, obsValue) => {\n      const arr = unwrapMaybeObsArray(optionArray);\n      const index = arr.findIndex((item) => getOptionValue(item) === obsValue);\n      elem.selectedIndex = index + 1;    // +1 for default option\n    })),\n\n    // When user picks a new item, use its value to update the observable.\n    dom.on('change', (e, elem) => {\n      const index = elem.selectedIndex;\n      const item = unwrapMaybeObsArray(optionArray)[index - 1];   // -1 for default option\n      // It should be impossible for the user to select an invalid option, but check just in case.\n      if (item !== undefined) {\n        obs.set(getOptionValue(item));\n      }\n    }),\n  );\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {dom, Observable, styled} from 'grainjs';\nimport * as bank from './bank';\n\nconst accountIds = ['A', 'B', 'C'];\nconst balanceObs = Observable.create(null, [0, 0, 0]);\n\nasync function updateBalanceObs() {\n  balanceObs.set(await Promise.all(accountIds.map(bank.getBalance)));\n}\n\nasync function initialize() {\n  try {\n    return await bank.initialize();\n  } finally {\n    await updateBalanceObs();\n  }\n}\n\nasync function transfer(accFrom: bank.AccountId, accTo: bank.AccountId, amount: number) {\n  try {\n    return await bank.transfer(accFrom, accTo, amount);\n  } finally {\n    await updateBalanceObs();\n  }\n}\n\nfunction buildPageDom() {\n  initialize();\n  const fmt = new Intl.NumberFormat('en-US', {style: 'currency', currency: 'USD'});\n  return [\n    cssBody.cls(''),\n    'Balances:',\n    accountIds.map((accId, i) =>\n      cssBalance(cssAccountId(accId),\n        cssAccountBalance(\n          dom.text((use) => fmt.format(use(balanceObs)[i]))\n        )\n      )\n    )\n  ];\n}\n\nconst cssBody = styled('div', `\n  margin: 0;\n  padding: 0;\n  font-family: sans-serif;\n  font-size: 14px;\n\n  display: flex;\n  align-items: center;\n  gap: 20px;\n`);\n\nconst cssBalance = styled('div', `\n  margin: 0 10px;\n  border: 1px solid grey;\n  border-radius: 4px;\n  display: flex;\n  align-items: center;\n`);\n\nconst cssAccountId = styled('div', `\n  padding: 6px 10px;\n  background-color: grey;\n  color: white;\n`);\n\nconst cssAccountBalance = styled('div', `\n  padding: 4px 8px;\n`);\n\ndom.update(document.body, buildPageDom());\n(window as any).bank = {initialize, transfer, getBalance: bank.getBalance};\n"],"sourceRoot":""}